<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>4択クイズ</title>
    <link href="https://cdn.jsdelivr.net/npm/swiper@11.2.8/swiper-bundle.min.css" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/swiper@11.2.8/swiper-bundle.min.js"></script>
    <link rel="stylesheet" href="./style.css">
    <link rel="stylesheet" href="https://fonts.googleapis.com/earlyaccess/notosansjapanese.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css">
    <link rel="stylesheet" href="../../modal.css">
    <link href="https://cdn.jsdelivr.net/npm/notie@4.3.1/dist/notie.min.css" rel="stylesheet">
    <link rel="stylesheet" href="./word-dictionary.css">
</head>

<body>
    <a href="javascript:pageback()" class="back"></a>
    <a href="javascript:void(0);" id="settings-btn" class="settings-btn">
        <i class="fas fa-cog"></i>
    </a>
    <div class="swiper-container">
        <div class="swiper-wrapper">
            <div class="swiper-slide slide1">
                <div class="resultbox">
                    <div class="resultbox1">
                        <div class="progress-title">
                            <i class="fas fa-book-open"></i>学習進捗
                        </div>
                        <div id="progress-stats">
                            <div>
                                <i class="fas fa-tasks"></i>総問題数:
                                <span id="total-questions">0</span>
                            </div>
                            <div>
                                <i class="fas fa-check-circle"></i>学習済み:
                                <span id="answered-questions">0</span>
                            </div>
                            <div>
                                <i class="fas fa-smile"></i>正解:
                                <span id="correct-answers">0</span>
                            </div>
                            <div>
                                <i class="fas fa-times-circle"></i>不正解:
                                <span id="wrong-answers">0</span>
                            </div>
                            <div>
                                <i class="fas fa-chart-pie"></i>進捗率:
                                <span id="progress-percentage">0</span>%
                                <div class="progress-bar-container">
                                    <div class="progress-bar" id="progress-bar" style="width: 0%">
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="resultbox2">
                        <div class="stats-title">
                            <i class="fas fa-chart-bar"></i>統計情報
                        </div>
                        <div id="performance-stats">
                            <div>
                                <i class="fas fa-percentage"></i>平均正解率:
                                <span id="avg-accuracy">0</span>%
                            </div>
                            <div>
                                <i class="fas fa-trophy"></i>最高連続正解:
                                <span id="max-streak">0</span>
                            </div>
                            <div>
                                <i class="fas fa-fire"></i>現在の連続正解:
                                <span id="current-streak">0</span>
                            </div>
                            <div>
                                <i class="fas fa-stopwatch"></i>平均解答時間:
                                <span id="avg-time">0</span>秒
                            </div>
                        </div>
                    </div>
                    <div class="resultbox3">
                        <div class="study-title">
                            <i class="fas fa-exclamation-circle"></i>学習中の問題
                        </div>
                        <ul id="study-list"></ul>
                        <button id="start-review-btn" class="review-btn">間違えた問題を復習する</button>
                    </div>
                    <div class="resultbox4">
                        <canvas id="performance-chart"></canvas>
                    </div>
                </div>
            </div>
            <div class="swiper-slide slide2">
                <div class="main">
                    <div id="review-mode-indicator" class="review-mode-indicator">復習モード中 (残り
                        <span id="review-count">0</span>問)
                    </div>
                    <div class="title">
                        <div id="question">
                        </div>
                    </div>
                    <ul class="sp" id="choice-answers">
                        <li>
                            <button id="answer1"></button>
                        </li>
                        <li>
                            <button id="answer2"></button>
                        </li>
                        <li>
                            <button id="answer3"></button>
                        </li>
                        <li>
                            <button id="answer4"></button>
                        </li>
                    </ul>
                    <div id="input-area" style="display: none;" class="no-swiping">
                        <input type="text" id="text-answer" placeholder="回答を入力">
                        <button id="submit-text-answer">回答</button>
                    </div>
                    <div id="handwriting-area" style="display: none;" class="no-swiping">
                        <div class="canvas-container no-swiping">
                            <canvas id="handwriting-canvas" width="400" height="200" class="no-swiping"></canvas>
                        </div>
                        <div class="handwriting-controls no-swiping">
                            <button id="clear-canvas" class="handwriting-btn">クリア</button>
                            <button id="submit-answer" class="handwriting-btn">回答する</button>
                        </div>
                    </div>
                    <!-- 英単語並び替えモード -->
                    <div id="word-arrange-area" style="display: none;" class="no-swiping">
                        <div class="word-arrange-instruction">単語を正しい順序でタップして文章を完成させてください
                        </div>
                        <div id="shuffled-words" class="shuffled-words-container">
                        </div>
                        <div id="arranged-words" class="arranged-words-container">
                            <div class="arranged-placeholder">ここに単語をタップして配置
                            </div>
                        </div>
                        <div class="word-arrange-controls">
                            <button id="clear-arrange" class="arrange-btn">リセット</button>
                            <button id="submit-arrange" class="arrange-btn">回答</button>
                        </div>
                    </div>
                    <!-- ○×問題モード -->
                    <div id="true-false-area" style="display: none;" class="no-swiping">
                        <div class="true-false-instruction">この問題文は正しいですか？
                        </div>
                        <div class="true-false-buttons">
                            <button id="true-btn" class="tf-btn true-btn">○ (正しい)</button>
                            <button id="false-btn" class="tf-btn false-btn">× (間違い)</button>
                        </div>
                    </div>
                </div>
                <div id="score">回答数: 0 正解数: 0 不正解数: 0 連続正解数:0 正答率: 0%
                </div>
                <button id="exit-review-btn" class="exit-review-btn">通常モードに戻る</button>
        </div>
        <div class="swiper-slide slide3">
            <div class="tangolist">
                <h1>単語リスト</h1>
                <div class="search-container">
                    <input type="text" class="searchbox" placeholder="検索" oninput="filterWords()">
                    <i class="fas fa-search search-icon"></i>
                    <div class="filter-options">
                        <select id="answerFilter" onchange="filterWords()">
                            <option value="all">すべての問題</option>
                            <option value="unanswered">未回答の問題</option>
                            <option value="correct">正解した問題</option>
                            <option value="incorrect">間違えた問題</option>
                        </select>
                    </div>
                </div>
                <ul id="wordList" class="custom-list"></ul>
            </div>
        </div>
    </div>
    <div class="swiper-button-next">
    </div>
    <div class="swiper-button-prev">
    </div>
    </div>
    <div class="modal micromodal-slide" id="modal-1" aria-hidden="true">
        <div class="modal__overlay" tabindex="-1" data-micromodal-close>
            <div class="modal__container" role="dialog" aria-modal="true" aria-labelledby="modal-1-title">
                <main class="modal__content" id="modal-1-content">
                    <div id="result-message" class="result-message">
                    </div>
                </main>
                <footer class="modal__footer modal__footer-centered">
                    <button class="modal__btn" data-micromodal-close
                        aria-label="Close this dialog window">私は間違えたことを深くお詫び、反省することを誓います。</button>
                </footer>
            </div>
        </div>
    </div>
    <div class="modal micromodal-slide" id="settings-modal" aria-hidden="true">
        <div class="modal__overlay" tabindex="-1" data-micromodal-close>
            <div class="modal__container" role="dialog" aria-modal="true" aria-labelledby="settings-modal-title">
                <header class="modal__header modal__header-centered">
                    <h2 id="settings-modal-title">設定</h2>
                </header>
                <main class="modal__content" id="settings-modal-content">
                    <div class="settings-section">
                        <h3>出題方法</h3>
                        <div class="settings-option">
                            <input type="checkbox" name="replace-mondai" id="replace-mondai">
                            <label for="replace-mondai">問題文と回答文を入れ換える</label>
                        </div>
                        <div class="settings-option">
                            <input type="checkbox" name="hardmode" id="hardmode">
                            <label for="hardmode">ハードモード</label>
                        </div>
                        <h3>出題順序</h3>
                        <div class="settings-option">
                            <input type="radio" id="random-mode" name="question-mode" value="random" checked>
                            <label for="random-mode">ランダムに出題</label>
                        </div>
                        <div class="settings-option">
                            <input type="radio" id="sequential-mode" name="question-mode" value="sequential">
                            <label for="sequential-mode">1問目から順に出題</label>
                        </div>
                        <h3>回答モード</h3>
                        <div class="settings-option">
                            <input type="radio" id="choice-mode" name="answer-mode" value="choice" checked>
                            <label for="choice-mode">4択モード</label>
                        </div>
                        <div class="settings-option">
                            <input type="radio" id="input-mode" name="answer-mode" value="input">
                            <label for="input-mode">入力モード</label>
                        </div>
                        <div class="settings-option">
                            <input type="radio" id="handwriting-mode" name="answer-mode" value="handwriting">
                            <label for="handwriting-mode">手書きモード(Beta)</label>
                        </div>
                        <div class="settings-option">
                            <input type="radio" id="word-arrange-mode" name="answer-mode" value="word-arrange">
                            <label for="word-arrange-mode">英単語並び替えモード</label>
                        </div>
                        <h3>リスニングモード</h3>
                        <a href="javascript:window.location.replace(`/listening?id=${encodeURIComponent(mondai)}`);"
                            style="color: black;text-decoration:none;">リスニングモードに移動</a>
                    </div>
                </main>
                <footer class="modal__footer" style="text-align: center;">
                    <button class="modal__btn" data-micromodal-close aria-label="Close this dialog window">閉じる</button>
                </footer>
            </div>
        </div>
    </div>
    <audio id="audioPlayer" class="hidden-player"></audio>
    <script src="https://cdn.jsdelivr.net/npm/micromodal@0.6.1/dist/micromodal.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/notie@4.3.1/dist/notie.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/js-cookie@3.0.5/dist/js.cookie.min.js"></script>
    <script src="./search.js"></script>
    <script src="./write.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js" defer></script>
    <script>
        // Swiperの初期化
        const swiper = new Swiper(".swiper-container", {
            direction: "horizontal",
            loop: false,
            initialSlide: 1,
            navigation: {
                nextEl: ".swiper-button-next",
                prevEl: ".swiper-button-prev",
            },
            mousewheel: false,
            noSwiping: true,
            noSwipingClass: "no-swiping",
        });

        let start;

        swiper.on('slideChangeTransitionEnd', function () {
            if (swiper.activeIndex === 1) {
                start = performance.now();
            }
            document.querySelector('.swiper-button-next').style.display = 'block';
            document.querySelector('.swiper-button-prev').style.display = 'block';
        });


        function getParam(name, url) {
            if (!url) url = window.location.href;
            name = name.replace(/\\/g, "\\\\").replace(/[\[\]]/g, "\\$&");
            var regex = new RegExp("[?&]" + name + "(=([^&#]*)|&|#|$)"),
                results = regex.exec(url);
            if (!results) return null;
            if (!results[2]) return '';
            return decodeURIComponent(results[2].replace(/\+/g, " "));
        }

        let mondai = getParam("id");
        let isCustom = false;
        let accid = Cookies.get('id');
        let password = Cookies.get('password');

        if (mondai == null) {
            let mondaiuserid = getParam("userid");
            let mondainame = getParam("name");
            if (mondaiuserid != null && mondainame != null) {
                isCustom = true;
                mondai = mondainame;
            } else {
                mondai = "hard"; //デフォルトの問題
            }
        }

        const questions = []; // Initialize questions array
        // 設定を一元管理するオブジェクト
        // グローバル設定（問題セット共通）
        const globalSettings = {
            replaceMondai: false, // 問題文と回答文を入れ替えるか
            hardMode: false, // ハードモード
            answerMode: 'choice' // 回答モード（'choice', 'input', 'handwriting', 'word-arrange', 'true-false'）
        };

        // 問題セット固有の設定
        const problemSettings = {
            questionMode: 'sequential', // 出題モード（'random'または'sequential'）
            currentQuestionIndex: 0 // 順番モードでの現在の問題インデックス
        };

        let answeredQuestions = new Set();
        let maxStreak = 0;
        let performanceHistory = [];
        let performanceChart = null;
        let questionStats = new Map();
        let answerTimes = [];
        let studyingQuestions = new Set();

        let isInReviewMode = false;
        let reviewQuestions = [];
        let reviewStreaks = {}; // { questionIndex: streakCount }


        function pageback() {
            const referrer = document.referrer;
            const currentHost = location.hostname;
            if (referrer) {
                try {
                    const referrerHost = new URL(referrer).hostname;
                    if (referrerHost === currentHost) {
                        history.back();
                    } else {
                        location.href = '../';
                    }
                } catch (e) {
                    location.href = '../';
                }
            } else {
                location.href = '../';
            }
        }

        // 音声再生用の関数
        function playWord(word) {
            const audioPlayer = document.getElementById('audioPlayer');
            audioPlayer.src = `/api/gen/speak/${encodeURIComponent(word)}`;
            audioPlayer.play().catch(() => { });
        }

        function loadQuestions() {
            const showErrorMessage = (errorMessage) => {
                notie.force({
                    type: 'error',
                    text: errorMessage,
                    buttonText: '閉じる',
                    callback: function () {
                        // エラーメッセージ表示後に実行する処理（例：トップページへのリダイレクト）
                        window.location.href = "../";
                    }
                });
                // タイトル領域にもエラーメッセージを表示
                // XSS対策として、errorMessageをエスケープしてから挿入
                const escapeHtml = (unsafe) => {
                    return unsafe
                        .replace(/&/g, "&amp;")
                        .replace(/</g, "&lt;")
                        .replace(/>/g, "&gt;")
                        .replace(/"/g, "&quot;")
                        .replace(/'/g, "&#039;");
                };

                document.getElementById('question').innerHTML =
                    `
                    <div class="error-message">
                        <i class="fas fa-exclamation-triangle"></i>
                        <p>${escapeHtml(errorMessage)}</p>
                        <button onclick="window.location.href='../'">トップページへ戻る</button>
                    </div>
                `;
            };

            const checkResponse = (response, source) => {
                if (!response.ok) {
                    if (response.status === 404) {
                        const errorMsg = `問題ファイルが見つかりませんでした（${source}: ${mondai}）`;
                        showErrorMessage(errorMsg);
                        throw new Error(errorMsg);
                    } else {
                        const errorMsg = `問題の読み込みに失敗しました（ステータス: ${response.status}）`;
                        showErrorMessage(errorMsg);
                        throw new Error(errorMsg);
                    }
                }
                return response;
            };

            if (isCustom) {
                return fetch("/api/get/mondai/" + accid + "/" + mondai + '.json')
                    .then(response => checkResponse(response, 'カスタム問題'))
                    .then(response => response.json())
                    .then(data => {
                        data.forEach(item => {
                            if (item.mondai == undefined) {
                                questions.push({
                                    word: item.word,
                                    description: item.description,
                                });
                            } else {
                                // mondaiフィールドが文字列の場合はパースを試みる
                                let mondaiData = item.mondai;
                                if (typeof mondaiData === 'string') {
                                    try {
                                        mondaiData = JSON.parse(mondaiData);
                                    } catch (e) {
                                        console.error('mondaiのパースに失敗:', e);
                                        mondaiData = [];
                                    }
                                } else if (!Array.isArray(mondaiData)) {
                                    mondaiData = [];
                                }

                                questions.push({
                                    word: item.word,
                                    description: item.description,
                                    mondai: mondaiData
                                });
                            }
                        });
                    })
                    .catch(error => {

                    });
            } else {
                // URLから開始と終了の問題番号を取得
                const startNum = parseInt(getParam("start")) || 1;
                const endNum = parseInt(getParam("end")) || null;
                // APIから範囲指定で問題を取得
                const apiUrl =
                    `/api/get/mondai/${mondai}.json?start=${startNum - 1}${endNum && endNum >= startNum ? `&end=${endNum}` : ''}`;
                return fetch(apiUrl)
                    .then(response => checkResponse(response, '範囲指定問題API'))
                    .then(response => response.json())
                    .then(data => {
                        data.forEach(item => {
                            const [word, description, mondaiData] = item.split('|');
                            if (mondaiData === undefined) {
                                questions.push({
                                    word, description
                                });
                            } else {
                                questions.push({
                                    word, description, mondai: JSON.parse(mondaiData)
                                });
                            }
                        });
                    })
                    .catch(error => {

                    });
            }
        }

        loadQuestions().then(async () => {
            document.getElementById('total-questions').textContent = questions.length;

            // 設定を読み込む
            loadSettings();

            // 英単語かどうかを判断して要素を制御
            checkAndControlEnglishOnlyFeatures();

            // 問題の選択方法をモードに応じて設定
            selectQuestionMode();

            // もしログインしていれば、サーバーから学習進捗データを読み込む
            if (accid && password) {
                await loadProgressFromServer();
            }

            // 最初の問題表示と進捗更新
            await showNextQuestion();
            updateProgressDisplay(); // 進捗表示を更新
            initializeChart();
            populateWordList();

            // --- タイマー制御: 初期ロード時に問題画面ならタイマー開始 ---
            if (swiper.activeIndex === 1) {
                start = performance.now();
            }
            // --- タイマー制御ここまで ---

            // 回答モードの設定を再確認（問題データ読み込み完了後）
            validateAnswerModeSettings();

            // 検索インデックスを事前構築（バックグラウンドで実行）
            setTimeout(() => {
                buildSearchIndex();

            }, 1000);
        });

        // 英単語かどうかを判断する関数
        function isEnglishWord(text) {
            if (!text || typeof text !== 'string') return false;
            // 英語の文字、数字、基本的な句読点のみを含む場合に英単語と判断
            // 日本語文字（ひらがな、カタカナ、漢字）が含まれていない場合に英語と判定
            return /^[a-zA-Z0-9\s.,'\-!?;:()]+$/.test(text.trim()) &&
                   !/[\u3040-\u309F\u30A0-\u30FF\u4E00-\u9FAF]/.test(text);
        }

        // 問題セットが英単語かどうかを判断する関数
        function isProblemSetEnglish() {
            if (!questions || questions.length === 0) {
                console.log('No questions available for English check');
                return false;
            }
            
            // 最初の10問（または全問題数が10未満の場合は全問題）をサンプルとして判断
            const sampleSize = Math.min(10, questions.length);
            let englishCount = 0;
            
            console.log(`Checking ${sampleSize} questions for English content:`);
            
            for (let i = 0; i < sampleSize; i++) {
                const question = questions[i];
                if (question && question.word) {
                    const isEnglish = isEnglishWord(question.word);
                    console.log(`Question ${i}: "${question.word}" -> ${isEnglish ? 'English' : 'Not English'}`);
                    if (isEnglish) {
                        englishCount++;
                    }
                }
            }
            
            const ratio = englishCount / sampleSize;
            const isEnglishSet = ratio >= 0.5; // 判定基準を80%から50%に緩和
            
            console.log(`English count: ${englishCount}/${sampleSize} (${(ratio * 100).toFixed(1)}%) -> ${isEnglishSet ? 'English Set' : 'Non-English Set'}`);
            
            return isEnglishSet;
        }

        // 英単語以外の場合に特定の要素を非表示にする関数
        function checkAndControlEnglishOnlyFeatures() {
            const isEnglish = isProblemSetEnglish();
            console.log('Checking English-only features. Is English set:', isEnglish);
            
            if (!isEnglish) {
                console.log('Non-English problem set detected. Hiding English-only features.');
                
                // 非表示にする要素を取得（英単語専用機能のみ）
                const replaceMondaiOption = document.querySelector('label[for="replace-mondai"]');
                const hardmodeOption = document.querySelector('label[for="hardmode"]');
                const wordArrangeOption = document.querySelector('label[for="word-arrange-mode"]');
                const listeningSection = document.querySelector('h3').parentElement;
                
                // 要素を非表示にする（親のsettings-optionクラスを持つdivを非表示にする）
                if (replaceMondaiOption) {
                    replaceMondaiOption.parentElement.style.display = 'none';
                }
                if (hardmodeOption) {
                    hardmodeOption.parentElement.style.display = 'none';
                }
                if (wordArrangeOption) {
                    wordArrangeOption.parentElement.style.display = 'none';
                }
                
                // リスニングモードセクション全体を非表示にする
                const listeningHeaders = document.querySelectorAll('h3');
                listeningHeaders.forEach(header => {
                    if (header.textContent.includes('リスニングモード')) {
                        header.style.display = 'none';
                        // 次の要素（リンク）も非表示にする
                        if (header.nextElementSibling) {
                            header.nextElementSibling.style.display = 'none';
                        }
                    }
                });
                
                // 英単語並び替えモードが選択されている場合は4択モードに変更
                if (globalSettings.answerMode === 'word-arrange') {
                    console.log('Word arrange mode was selected but switching to choice mode for non-English set');
                    globalSettings.answerMode = 'choice';
                    document.getElementById('choice-mode').checked = true;
                    saveSettings();
                    
                    // ユーザーに通知
                    setTimeout(() => {
                        notie.alert({
                            type: 'warning',
                            text: '英単語並び替えモードは英単語問題でのみ利用可能です。4択モードに変更しました。',
                            time: 3
                        });
                    }, 1000);
                }
                
                // ハードモードが有効になっている場合は無効にする
                if (globalSettings.hardMode) {
                    globalSettings.hardMode = false;
                    document.getElementById('hardmode').checked = false;
                    saveSettings();
                }
            } else {
                console.log('English problem set confirmed. English-only features available.');
            }
        }

        // 回答モード設定の妥当性を検証する関数（問題データ読み込み完了後に呼ばれる）
        function validateAnswerModeSettings() {
            console.log('Validating answer mode settings after questions loaded');
            
            // 英単語並び替えモードが選択されているかチェック
            if (globalSettings.answerMode === 'word-arrange') {
                const isEnglishSet = isProblemSetEnglish();
                console.log('Current mode is word-arrange. English set check:', isEnglishSet);
                
                if (!isEnglishSet) {
                    console.log('Switching from word-arrange to choice mode due to non-English set');
                    globalSettings.answerMode = 'choice';
                    document.getElementById('choice-mode').checked = true;
                    saveSettings();
                    
                    // UI表示も更新
                    document.getElementById('choice-answers').style.display = 'block';
                    document.getElementById('word-arrange-area').style.display = 'none';
                    
                    // ユーザーに通知
                    setTimeout(() => {
                        notie.alert({
                            type: 'warning',
                            text: '英単語並び替えモードは英単語問題でのみ利用可能です。4択モードに変更しました。',
                            time: 3
                        });
                    }, 500);
                } else {
                    console.log('Word arrange mode is valid for this English problem set');
                }
            }
        }

        function populateWordList() {
            let listHTML = ''; // HTML文字列を構築

            questions.forEach(question => {
                let titleHTML, contentHTML;
                const titleClass = 'tangotitle';
                const contentClass = 'content no-swiping';

                titleHTML = question.word;
                contentHTML = question.description;

                const isEnglishWord = /^[a-zA-Z0-9s.,'\-]+$/.test(titleHTML.trim());
                const speakerIcon = isEnglishWord ?
                    `  <i class="fas fa-volume-up speak-icon" onclick="playWord('${titleHTML}')"></i>` :
                    '';

                if (contentHTML.endsWith("か。") || contentHTML.endsWith("答えよ。") ||
                    contentHTML.endsWith("答えなさい。")) {
                    listHTML +=
                        `<li><div class="${contentClass}">${contentHTML}${speakerIcon}</div><div class="${titleClass}">${titleHTML}</div></li>`;
                } else {
                    listHTML +=
                        `<li><div class="${titleClass}">${titleHTML}${speakerIcon}</div><div class="${contentClass}">${contentHTML}</div></li>`;
                }
            });

            document.getElementById('wordList').innerHTML = listHTML;
        }

        let currentIndex;
        let totalCount = 0;
        let correctCount = 0;
        let wrongCount = 0;
        let renzokuseikai = 0;

        async function showNextQuestion() {
            if (currentIndex === undefined || currentIndex < 0 || currentIndex >=
                questions.length) {

                if (questions.length > 0) {
                    currentIndex = 0;
                } else {
                    document.getElementById('question').innerHTML = "問題がありません。";
                    return;
                }
            }
            const question = questions[currentIndex];
            if (!question) {

                return;
            }

            const title = document.getElementById('question');
            const isReversed = globalSettings.replaceMondai;
            const isHardMode = globalSettings.hardMode;
            screenWidth = window.innerWidth;
            screenHeight = window.innerHeight;

            // 問題文表示
            if (!isHardMode) {
                if (isReversed) {
                    title.innerHTML = question.word;
                    textlength = question.word.length;
                } else {
                    title.innerHTML = question.description;
                    textlength = question.description.length;
                }


                if (screenWidth < 600 || screenHeight < 600) {
                    if (textlength >= 150) title.style.fontSize = "0.8em";
                    else if (textlength >= 100) title.style.fontSize = "1em";
                    else title.style.fontSize = "1.3em";
                } else if (screenWidth < 1200 || screenHeight < 800) {
                    if (textlength >= 150) title.style.fontSize = "1em";
                    else if (textlength >= 100) title.style.fontSize = "1.2em";
                    else title.style.fontSize = "1.4em";
                } else {
                    if (textlength >= 150) title.style.fontSize = "1.2em";
                    else if (textlength >= 100) title.style.fontSize = "1.3em";
                    else title.style.fontSize = "1.4em";
                }
            }
            // --- 選択肢生成 ---
            let correctAnswer = isReversed ? question.description : question.word;
            let options = [correctAnswer]; // 正解は必ず含める
            let incorrectOptions = [];
            let otherOptions = []; // すべてのケースで使用できるように変数を定義

            // 1. 不正解選択肢の候補を集める
            if (isReversed) {
                // 反転モード: 他の問題の説明文を候補に
                questions.forEach((q, index) => {
                    if (index !== currentIndex && q.description !== correctAnswer && !
                        incorrectOptions.includes(q.description)) {
                        incorrectOptions.push(q.description);
                    }
                });
            } else {
                // 通常モード
                if (question.mondai) {
                    // mondaiフィールドあり: 指定の不正解選択肢を優先使用
                    const providedIncorrect = Array.isArray(question.mondai) ? question.mondai : [];

                    // mondaiの選択肢を優先的に使用（正解との重複を除外）
                    providedIncorrect.forEach(opt => {
                        if (opt !== correctAnswer && !incorrectOptions.includes(opt)) {
                            incorrectOptions.push(opt);
                        }
                    });
                }

                // 他の問題の単語も候補に追加 (mondaiの選択肢と区別するため別の配列に)
                const otherOptions = [];
                questions.forEach((q, index) => {
                    if (index !== currentIndex && q.word !== correctAnswer && !
                        incorrectOptions.includes(q.word)) {
                        otherOptions.push(q.word);
                    }
                });
            }

            // 2. ハードモード処理 (文章問題の生成)
            if (isHardMode && !isReversed) {
                // ハードモード時は /api/get/sentences から文章を取得して問題にする
                try {
                    const response = await fetch('/api/get/sentences', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            words: [correctAnswer]
                        }) // 正解の単語を送信
                    });
                    if (!response.ok) {
                        throw new Error(`API request failed with status ${response.status}`);
                    }
                    const sentenceData = await response.json();
                    if (sentenceData.results && sentenceData.results[correctAnswer] &&
                        sentenceData.results[correctAnswer].length > 0) {
                        const sentences = sentenceData.results[correctAnswer];
                        const sentenceForQuestion = sentences[Math.floor(Math.random() * sentences
                            .length)]; // ランダムに1文選択

                        // 問題文を書き換え
                        // グローバルな正規表現を使用して、すべての | を <br> に置換
                        title.innerHTML = sentenceForQuestion.replace(/|/g, "<br>").replace(new RegExp(
                            escapeRegExp(correctAnswer), "g"), "(     )");

                        // 正規表現のエスケープ関数（新たに追加）
                        function escapeRegExp(string) {
                            return string.replace(/[.*+?^${}()|[]\]/g, '\$&');
                        }
                        // フォントサイズ調整 (新しい問題文の長さに合わせて)
                        textlength = sentenceForQuestion.length;
                        if (screenWidth < 600 || screenHeight < 600) {
                            if (textlength >= 150) title.style.fontSize = "0.8em";
                            else if (textlength >= 100) title.style.fontSize = "1em";
                            else title.style.fontSize = "1.3em";
                        } else if (screenWidth < 1200 || screenHeight < 800) {
                            if (textlength >= 150) title.style.fontSize = "1em";
                            else if (textlength >= 100) title.style.fontSize = "1.2em";
                            else title.style.fontSize = "1.4em";
                        } else {
                            if (textlength >= 150) title.style.fontSize = "1.2em";
                            else if (textlength >= 100) title.style.fontSize = "1.3em";
                            else title.style.fontSize = "1.4em";
                        }

                        // 選択肢は元の単語が正解、他はダミーまたは他の単語
                        options = [correctAnswer]; // 正解は元の単語
                        incorrectOptions = []; // 不正解選択肢を初期化

                        // 他の問題の単語を不正解の候補として集める
                        questions.forEach((q, index) => {
                            if (index !== currentIndex && q.word !== correctAnswer && !
                                incorrectOptions.includes(q.word)) {
                                incorrectOptions.push(q.word);
                            }
                        });

                    }
                } catch (error) {
                    console.error('Error fetching sentences:', error);
                    // エラーが発生した場合は通常の選択肢生成に戻る
                    incorrectOptions = [];
                    questions.forEach((q, index) => {
                        if (index !== currentIndex && q.word !== correctAnswer && !
                            incorrectOptions.includes(q.word)) {
                            incorrectOptions.push(q.word);
                        }
                    });
                }
            }


            // 3. 最終的な選択肢リストを作成 (不正解選択肢を追加)
            // まず、mondaiで指定された選択肢を優先的に追加
            incorrectOptions.sort(() => Math.random() - 0.5); // 不正解候補をシャッフル
            while (options.length < 4 && incorrectOptions.length > 0) {
                const incorrectOption = incorrectOptions.shift();
                if (!options.includes(incorrectOption)) { // 重複チェック
                    options.push(incorrectOption);
                }
            }

            // mondaiの選択肢だけでは足りない場合、他の問題から選択肢を追加
            if (options.length < 4 && otherOptions.length > 0) {
                otherOptions.sort(() => Math.random() - 0.5); // 他の候補もシャッフル
                while (options.length < 4 && otherOptions.length > 0) {
                    const otherOption = otherOptions.shift();
                    if (!options.includes(otherOption)) { // 重複チェック
                        options.push(otherOption);
                    }
                }
            }

            // 4. ダミー選択肢ではなく、他の問題からもっと広く選択肢を選ぶ
            if (options.length < 4) {
                // すべての問題から選択肢候補を収集（現在未使用のもの）
                const allPossibleOptions = [];
                questions.forEach((q, idx) => {
                    // 現在の問題と選択肢に既に入っているものを除外
                    if (idx !== currentIndex) {
                        // isReversedに応じて、適切なフィールドを選択肢として使用
                        const optionText = isReversed ? q.description : q.word;
                        if (!options.includes(optionText)) {
                            allPossibleOptions.push(optionText);
                        }
                    }
                });

                // シャッフルして使う
                allPossibleOptions.sort(() => Math.random() - 0.5);

                while (options.length < 4 && allPossibleOptions.length > 0) {
                    options.push(allPossibleOptions.shift());
                }

                // それでも足りない場合（問題数が少ない場合など）は末尾に番号付き選択肢を追加
                let backupCount = 1;
                while (options.length < 4) {
                    const backupOption = `選択肢${backupCount++}`;
                    if (!options.includes(backupOption)) {
                        options.push(backupOption);
                    }
                }
            }

            // 5. 選択肢をシャッフルして表示（4択モードの場合のみ）
            if (globalSettings.answerMode === 'choice') {
                options.sort(() => Math.random() - 0.5);
                options.forEach((answer, index) => {
                    document.getElementById('answer' + (index + 1)).textContent = answer;
                });
            }
            // --- 選択肢生成ここまで ---

            // 英単語並び替えモードの処理
            if (globalSettings.answerMode === 'word-arrange') {
                setupWordArrangeMode(correctAnswer);
            }


            // --- タイマー制御: ここでのタイマー開始を削除 ---
            // start = performance.now();
            // --- タイマー制御ここまで ---

            document.getElementById('exit-review-btn').style.display = isInReviewMode ?
                'block' : 'none';
            if (isInReviewMode) {
                document.getElementById('review-count').textContent = reviewQuestions.length;
            }
        }

        function calculateAccuracy() {
            return totalCount === 0 ? 0 : (correctCount / totalCount) * 100;
        }

        function calculateAverageTime() {
            if (answerTimes.length === 0) return 0;
            const sum = answerTimes.reduce((a, b) => a + b, 0);
            return (sum / answerTimes.length / 1000).toFixed(1);
        }

        function initializeChart() {
            const ctx = document.getElementById('performance-chart').getContext('2d');
            performanceChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [{
                        label: '正解率推移',
                        data: [],
                        borderColor: '#007bff',
                        tension: 0.1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            beginAtZero: true,
                            max: 100
                        }
                    }
                }
            });
        }

        function updateChart() {
            if (performanceChart && totalCount > 0) {
                const accuracy = calculateAccuracy();
                performanceHistory.push(accuracy);

                performanceChart.data.labels = Array.from({
                    length: performanceHistory.length
                }, (_, i) => i + 1);
                performanceChart.data.datasets[0].data = performanceHistory;
                performanceChart.update();
            }
        }

        function updateStudyList() {
            const studyList = document.getElementById('study-list');
            studyList.innerHTML = '';

            // studyingQuestions に含まれるインデックスの問題のみ表示
            for (let index of studyingQuestions) {
                if (!questionStats.has(index)) continue; // 統計情報がない場合はスキップ

                const stats = questionStats.get(index);
                const question = questions[index];
                const li = document.createElement('li');
                // 'wrong'クラスは不正解の場合、'long-time'は時間がかかった場合（判定ロジックは必要なら追加）
                li.className =
                    `study-item ${stats.isWrong ? 'wrong-answer' : ''} ${stats.isLongTime ? 'long-time' : ''}`;

                let statusText = [];
                if (stats.isWrong) statusText.push('間違えた問題');
                if (stats.isLongTime) statusText.push('時間がかかった問題');

                li.innerHTML =
                    `
                    <strong>${question.word}</strong><br>
                    <small>${statusText.join(' / ')}</small>
                `;
                studyList.appendChild(li);
            }
            // 復習ボタンの表示/非表示
            document.getElementById('start-review-btn').style.display = studyingQuestions
                .size > 0 ? 'block' : 'none';
        }


        function updateStats() {
            document.getElementById('answered-questions').textContent = answeredQuestions
                .size;
            document.getElementById('correct-answers').textContent = correctCount;
            document.getElementById('wrong-answers').textContent = wrongCount;
            const progressPercentage = questions.length > 0 ? (answeredQuestions.size /
                questions.length) * 100 : 0; // Avoid division by zero
            document.getElementById('progress-percentage').textContent =
                progressPercentage.toFixed(1);
            document.getElementById('progress-bar').style.width = progressPercentage +
                '%';

            document.getElementById('avg-accuracy').textContent = calculateAccuracy().toFixed(
                1);
            document.getElementById('max-streak').textContent = maxStreak;
            document.getElementById('current-streak').textContent = renzokuseikai;
            document.getElementById('avg-time').textContent = calculateAverageTime();

            updateChart();
            updateStudyList();
        }

        async function onAnswerClick(e) {
            document.querySelector('.swiper-button-next').style.display = 'none';
            document.querySelector('.swiper-button-prev').style.display = 'none';

            // --- タイマー制御: startが未定義の場合のフォールバック ---
            if (typeof start === 'undefined' || start === null) {

                start = performance.now(); // 念のため現在時刻を開始時刻とする
            }
            // --- タイマー制御ここまで ---

            const endTime = performance.now();
            const timeTaken = endTime - start;
            answerTimes.push(timeTaken);
            start = null; // 次の問題が表示されるまでタイマー開始時刻をリセット

            const avgTime = calculateAverageTime();
            // 時間がかかったかの判定: 平均の1.5倍以上、かつ最低でも5秒以上かかった場合など調整可能
            const isLongTime = timeTaken / 1000 > Math.max(5, avgTime * 1.5);


            if (!questionStats.has(currentIndex)) {
                questionStats.set(currentIndex, {
                    attempts: 0,
                    correctAnswers: 0,
                    averageTime: 0,
                    isLongTime: false,
                    isWrong: false
                });
            }

            const stats = questionStats.get(currentIndex);
            stats.attempts++;
            // 平均解答時間の計算を更新 (より正確に)
            stats.averageTime = ((stats.averageTime || 0) * (stats.attempts - 1) +
                timeTaken) / stats.attempts;
            stats.isLongTime = isLongTime || stats.isLongTime; // 一度でも時間がかかったらフラグを立てる

            answeredQuestions.add(currentIndex);
            totalCount++;

            const isReversed = globalSettings.replaceMondai;
            const correctAnswer = isReversed ? questions[currentIndex].description :
                questions[currentIndex].word;

            if (e.target.textContent === correctAnswer) { // 正解の場合
                stats.isWrong = false; // 正解したので不正解フラグはリセット
                if (isInReviewMode) {
                    // --- 復習モードの正解処理 ---
                    reviewStreaks[currentIndex] = (reviewStreaks[currentIndex] || 0) + 1; // reviewStreaks[currentIndex]が存在しない場合も考慮
                    if (reviewStreaks[currentIndex] >= 2) {
                        const indexToRemove = reviewQuestions.indexOf(currentIndex);
                        if (indexToRemove > -1) {
                            reviewQuestions.splice(indexToRemove, 1);
                        }
                        delete reviewStreaks[currentIndex];
                        studyingQuestions.delete(currentIndex); // 復習完了したら学習中リストからも削除

                        if (reviewQuestions.length === 0) {
                            isInReviewMode = false;
                            document.getElementById('review-mode-indicator').style.display = 'none';
                            document.getElementById('exit-review-btn').style.display = 'none';
                            notie.alert({
                                type: 'success',
                                text: '復習完了！お疲れ様でした。',
                                time: 3
                            });
                            document.getElementById('review-count').textContent = reviewQuestions.length;

                            swiper.slideTo(0); // 学習進捗画面へ
                            updateStats();
                            saveProgressToServer(); // 進捗保存
                            return; // 次の問題表示に進まない
                        }
                    }
                    // 通常の正解処理も実行 (スコア加算など)
                    correctCount++;
                    renzokuseikai++;
                    if (renzokuseikai > maxStreak) {
                        maxStreak = renzokuseikai;
                    }
                    stats.correctAnswers = (stats.correctAnswers || 0) + 1; // correctAnswersが存在しない場合も考慮
                    notie.alert({
                        type: 1,
                        text: '正解',
                        time: 1
                    });
                    updateProgressDisplay();
                    document.getElementById('review-count').textContent = reviewQuestions.length;

                    updateStats();
                    nextIndex();
                    await showNextQuestion();
                    sendScore("add_correct", accid, password);
                    saveProgressToServer(); // 進捗保存
                    // --- 復習モードの正解処理 ここまで ---
                } else {
                    // --- 通常モードの正解処理 ---
                    correctCount++;
                    renzokuseikai++;
                    if (renzokuseikai > maxStreak) {
                        maxStreak = renzokuseikai;
                    }
                    stats.correctAnswers = (stats.correctAnswers || 0) + 1; // correctAnswersが存在しない場合も考慮
                    // 正解回数が2回以上、かつ時間がかかっていない場合に学習中から外す
                    if (stats.correctAnswers >= 2 && !stats.isLongTime) {
                        studyingQuestions.delete(currentIndex);
                    } else if (stats.correctAnswers >= 1 && isLongTime) {
                        studyingQuestions.add(currentIndex); // 1回正解でも時間がかかったら学習中に戻す
                    }
                    notie.alert({
                        type: 1,
                        text: '正解',
                        time: 1
                    });
                    updateProgressDisplay();
                    updateStats();
                    nextIndex();
                    await showNextQuestion();
                    sendScore("add_correct", accid, password);
                    saveProgressToServer(); // 進捗保存
                    // --- 通常モードの正解処理 ここまで ---
                }
            } else { // 不正解の場合
                stats.isWrong = true; // 不正解フラグを立てる
                studyingQuestions.add(currentIndex); // 不正解なら必ず学習中リストへ
                if (isInReviewMode) {
                    // --- 復習モードの不正解処理 ---
                    reviewStreaks[currentIndex] = 0; // 連続正解リセット
                    // 通常の不正解処理も実行 (スコア加算など)
                    wrongCount++;
                    renzokuseikai = 0;
                    // stats.isWrong = true; // 上で設定済み
                    // studyingQuestions.add(currentIndex); // 上で設定済み
                    let question = questions[currentIndex];
                    let questionText, answerText;
                    const isHardModeCurrent = globalSettings.hardMode;

                    if (isReversed) {
                        questionText = question.word;
                        answerText = question.description;
                    } else {
                        if (isHardModeCurrent) {
                            questionText = document.getElementById('question').innerHTML; // ハードモード時は表示されている問題文
                        } else {
                            questionText = question.description; // 通常モード
                        }
                        answerText = question.word;
                    }
                    notie.force({
                        type: 'error',
                        text: '<div class="popup">問題：' + questionText + '<br><br>正しい回答:' +
                            answerText + "<br>あなたの回答:" + e.target.textContent + '</div>',
                        buttonText: '私は間違えたことを深くお詫び、反省することを誓います。',
                        callback: async function () {
                            updateProgressDisplay();
                            updateStats();
                            nextIndex(); // 復習モードでも次の問題へ
                            await showNextQuestion();
                            sendScore("add_bad", accid, password);
                            saveProgressToServer(); // 進捗保存
                        }
                    });
                } else {
                    wrongCount++;
                    renzokuseikai = 0;
                    // stats.isWrong = true; // 上で設定済み
                    // studyingQuestions.add(currentIndex); // 上で設定済み
                    let question = questions[currentIndex];
                    let questionText, answerText;
                    const isHardModeCurrent = globalSettings.hardMode;

                    if (isReversed) {
                        questionText = question.word;
                        answerText = question.description;
                    } else {
                        if (isHardModeCurrent) {
                            questionText = document.getElementById('question').innerHTML; // ハードモード時は表示されている問題文
                        } else {
                            questionText = question.description; // 通常モード
                        }
                        answerText = question.word;
                    }
                    notie.force({
                        type: 'error',
                        text: '<div class="popup">問題：' + questionText + '<br><br>正しい回答:' +
                            answerText + "<br>あなたの回答:" + e.target.textContent + '</div>',
                        buttonText: '私は間違えたことを深くお詫び、反省することを誓います。',
                        callback: async function () {
                            updateProgressDisplay();
                            updateStats();
                            // 通常モードの不正解時は同じ問題を表示（nextIndexを呼ばない）
                            // nextIndex(); // この行を削除またはコメントアウト
                            await showNextQuestion();
                            sendScore("add_bad", accid, password);
                            saveProgressToServer(); // 進捗保存
                        }
                    });
                }
            }

            // 時間がかかった場合も学習中にする（正解・不正解共通）
            if (isLongTime) {
                studyingQuestions.add(currentIndex);
                // 必要ならstats.isLongTimeフラグを再度確認してセット
                stats.isLongTime = true;
                updateStats(); // 表示更新
            }
        }
        // 設定をlocalStorageから読み込む関数
        function loadSettings() {
            // グローバル設定を読み込む（一括で）
            try {
                const savedGlobalSettings = localStorage.getItem('quizbox_global_settings');
                if (savedGlobalSettings) {
                    const parsedSettings = JSON.parse(savedGlobalSettings);
                    // 有効なプロパティのみをグローバル設定に適用
                    if (parsedSettings.replaceMondai !== undefined) globalSettings.replaceMondai =
                        parsedSettings.replaceMondai;
                    if (parsedSettings.hardMode !== undefined) globalSettings.hardMode =
                        parsedSettings.hardMode;
                    if (parsedSettings.answerMode) globalSettings.answerMode = parsedSettings.answerMode;
                }
            } catch (e) {
                console.error('グローバル設定の読み込みエラー:', e);
                // 個別設定から読み込み（後方互換性）
                globalSettings.replaceMondai = localStorage.getItem('replace_mondai') ===
                    'true';
                globalSettings.hardMode = localStorage.getItem('hard_mode') === 'true';
                globalSettings.answerMode = localStorage.getItem('answer_mode') || 'choice';
            }

            // 問題セット固有の設定を読み込む
            try {
                // 範囲指定がある場合は、それを含めたキーを生成
                const startParam = getParam("start");
                const endParam = getParam("end");
                let problemSetKey = mondai;

                if (startParam && endParam) {
                    problemSetKey = `${mondai}_${startParam}_${endParam}`;
                }

                const key = `quizbox_problem_settings_${problemSetKey}`;
                const savedProblemSettings = localStorage.getItem(key);
                if (savedProblemSettings) {
                    const parsedSettings = JSON.parse(savedProblemSettings);
                    // 有効なプロパティのみを問題セット設定に適用
                    if (parsedSettings.questionMode) problemSettings.questionMode =
                        parsedSettings.questionMode;
                    if (parsedSettings.currentQuestionIndex !== undefined) {
                        problemSettings.currentQuestionIndex = parsedSettings.currentQuestionIndex;
                    }
                }
            } catch (e) {
                console.error('問題セット設定の読み込みエラー:', e);
                // 個別設定から読み込み（後方互換性）
                problemSettings.questionMode = localStorage.getItem('question_mode_' +
                    mondai) || 'sequential';
                problemSettings.currentQuestionIndex = parseInt(localStorage.getItem(
                    'current_question_index_' + mondai) || '0');
            }

            // UIに設定を反映
            document.getElementById('replace-mondai').checked = globalSettings.replaceMondai;
            document.getElementById('hardmode').checked = globalSettings.hardMode;
            document.getElementById(problemSettings.questionMode + '-mode').checked =
                true;
            document.getElementById(globalSettings.answerMode + '-mode').checked = true;
        }

        // 設定を保存する関数
        function saveSettings() {
            // グローバル設定を一括で保存
            localStorage.setItem('quizbox_global_settings', JSON.stringify(globalSettings));

            // 問題セット固有の設定を一括で保存（範囲指定がある場合はそれも含める）
            const startParam = getParam("start");
            const endParam = getParam("end");
            let problemSetKey = mondai;

            // start/endパラメータが指定されている場合は、それをキーに含める
            if (startParam && endParam) {
                problemSetKey = `${mondai}_${startParam}_${endParam}`;
            }

            const key = `quizbox_problem_settings_${problemSetKey}`;
            localStorage.setItem(key, JSON.stringify(problemSettings));
        }

        function selectQuestionMode() {
            // 問題セット設定から現在のモードを取得
            const savedMode = problemSettings.questionMode;
            document.getElementById(savedMode + '-mode').checked = true; // UIに反映

            if (savedMode === 'sequential') {
                // 保存されている進捗があれば復元、なければ0から開始
                currentIndex = problemSettings.currentQuestionIndex;
                if (currentIndex >= questions.length || currentIndex < 0) {
                    currentIndex = 0; // インデックスが範囲外なら最初から
                    problemSettings.currentQuestionIndex = 0; // 設定も更新
                    saveSettings(); // 保存
                }
            } else {
                // ランダムモード
                if (questions.length > 0) {
                    currentIndex = Math.floor(Math.random() * questions.length);
                } else {
                    currentIndex = undefined; // 問題がない場合
                }
            }
        }

        function nextIndex() {
            if (questions.length === 0) return; // 問題がない場合は何もしない

            if (isInReviewMode) {
                if (reviewQuestions.length === 0) {
                    // 復習完了時の処理 (念のため)
                    isInReviewMode = false;
                    document.getElementById('review-mode-indicator').style.display = 'none';
                    document.getElementById('exit-review-btn').style.display = 'none';
                    notie.alert({
                        type: 'success',
                        text: '復習完了！',
                        time: 2
                    });
                    swiper.slideTo(0);
                    saveProgressToServer(); // 最後に保存
                    return; // 通常のモード選択に進まない
                }
                let lastReviewIndex = currentIndex;
                // reviewQuestionsが空でないことを確認
                if (reviewQuestions.length > 0) {
                    do {
                        currentIndex = reviewQuestions[Math.floor(Math.random() * reviewQuestions.length)];
                    } while (reviewQuestions.length > 1 && currentIndex === lastReviewIndex); // 問題が2つ以上ある場合のみループ
                } else {
                    // 復習対象がなくなったら復習モードを終了
                    isInReviewMode = false;
                    document.getElementById('review-mode-indicator').style.display = 'none';
                    document.getElementById('exit-review-btn').style.display = 'none';
                    notie.alert({
                        type: 'success',
                        text: '復習完了！',
                        time: 2
                    });
                    swiper.slideTo(0);
                    saveProgressToServer(); // 最後に保存
                    return;
                }

                updateProgressDisplay(); // 復習モードでも進捗表示を更新
                return; // 通常のモード選択に進まない
            }

            const isSequential = problemSettings.questionMode === 'sequential';

            let lastIndex = currentIndex;

            if (isSequential) {
                // 順番モードでは次の問題へ
                currentIndex = (currentIndex + 1) % questions.length;
                // 進捗を保存
                problemSettings.currentQuestionIndex = currentIndex;
                saveSettings();

                // 最後の問題に達して0に戻ったらランダムモードに切り替えるか、通知を出す
                if (currentIndex === 0 && lastIndex === questions.length - 1) { // 厳密に一周したかチェック
                    // ランダムモードに自動で切り替える場合
                    // localStorage.setItem('question_mode_' + mondai, 'random');
                    // document.getElementById('random-mode').checked = true;
                    // document.getElementById('sequential-mode').checked = false;
                    notie.alert({
                        type: 'success',
                        text: 'すべての問題を終了しました。引き続き順番に表示します。', // または 'ランダムモードに切り替えます'
                        time: 3
                    });
                    // selectQuestionMode(); // モードが変わった場合、再選択ロジックを呼ぶ
                }
            } else {
                // ランダムモード（現状の動作）
                if (questions.length > 1) { // 問題が2つ以上ある場合のみループ
                    do {
                        currentIndex = Math.floor(Math.random() * questions.length);
                    } while (currentIndex === lastIndex);
                } else {
                    // 問題が1つしかない場合はインデックスは変わらない
                    currentIndex = 0;
                }
            }

            updateProgressDisplay();
        }

        // 進捗表示を更新する関数
        function updateProgressDisplay() {
            const isSequential = problemSettings.questionMode === 'sequential';

            let scoreText =
                `
                回答数: ${totalCount}
                正解数: ${correctCount}
                不正解数: ${wrongCount}
                連続正解数: ${renzokuseikai}
                正答率: ${calculateAccuracy().toFixed(1)}%
            `;

            if (isSequential && questions.length > 0) {
                // 順番モードでは問題番号も表示 (currentIndexが有効な場合のみ)
                if (currentIndex !== undefined && currentIndex >= 0 && currentIndex <
                    questions.length) {
                    scoreText = `問題 ${currentIndex + 1}/${questions.length}<br>` + scoreText;
                }
            }
            // 復習モードの表示
            if (isInReviewMode) {
                scoreText = `復習中 残り ${reviewQuestions.length} 問<br>` + scoreText;
            }


            document.getElementById('score').innerHTML = scoreText;
        }


        function sendScore(endpoint, id, password) {
            if (!id || !password) return; // ID/Passがない場合は送信しない
            const currentURL = location;
            const url = currentURL.protocol + "//" + currentURL.host + "/api/" + endpoint;
            fetch(url, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    "id": id,
                    "password": password,
                })
            }).then(response => {
                if (!response.ok) {
                    // 401 Unauthorized のようなエラーも考慮

                    // throw new Error('Network response was not ok ' + response.statusText);
                    return null; // エラー時は null を返すなど
                }
                return response.json();
            }).then(data => {
                if (data) {

                }
                // saveProgressToServer(); // スコア送信成功時にも保存 (頻繁すぎる可能性あり)
            }).catch((error) => {

            });
        }

        // サーバーに学習進捗データを保存する関数
        async function saveProgressToServer() { // Make async
            const userId = Cookies.get('id');
            const password = Cookies.get('password');
            if (!userId || !password) return; // ID/Passがない場合は保存しない

            // 範囲指定がある場合は、問題セット名に範囲も含める
            let problemSet = mondai || 'default';
            const startParam = getParam("start");
            const endParam = getParam("end");

            if (startParam && endParam) {
                problemSet = `${mondai}_${startParam}_${endParam}`;
            }
            const totalQuestions = questions.length;

            // 1. 詳細データ (details) を作成
            const detailsData = {
                answeredQuestions: Array.from(answeredQuestions), // Convert Set to Array
                questionStats: Object.fromEntries(questionStats), // Convert Map to Object
                maxStreak: maxStreak,
                performanceHistory: performanceHistory,
                answerTimes: answerTimes,
                studyingQuestions: Array.from(studyingQuestions), // Convert Set to Array
            };

            // learned, learning, unlearned の計算ロジックはそのまま
            let learnedCount = 0;
            let learningCount = 0;

            questionStats.forEach((stats, index) => {
                if (answeredQuestions.has(index)) {
                    // 学習済み条件：正解2回以上 AND 時間がかかっていない
                    if (stats.correctAnswers >= 2 && !stats.isLongTime) {
                        learnedCount++;
                    } else { // それ以外（1回正解、不正解、時間がかかった）は学習中
                        learningCount++;
                    }
                }
            });

            // studyingQuestions に含まれているが stats にない（＝まだ解答していない）ものは learningCount に含めるべきか？
            // answeredQuestions に基づいて計算する方が一貫性がある
            studyingQuestions.forEach(index => {
                if (!answeredQuestions.has(index)) {
                    // まだ解答していないが復習リストに入っている場合？ 基本的には解答済みのはず
                    // learningCount++; // 必要ならカウント
                } else if (!questionStats.has(index) || (questionStats.get(index).correctAnswers <
                    2 || questionStats.get(index).isLongTime)) {
                    // 解答済みだが学習済み条件を満たさない場合、learningCountに含まれているはず
                }
            });


            const unlearnedCount = totalQuestions - learnedCount - learningCount;

            const summaryData = {
                learned: learnedCount,
                learning: learningCount,
                unlearned: Math.max(0, unlearnedCount), // 負にならないように
                total: totalQuestions
            };


            try {
                const response = await fetch('/api/save_progress', { // Use relative path
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        id: userId,
                        password: password,
                        problem_set: problemSet,
                        summary: summaryData, // Send summary data
                        details: detailsData // Send details data
                    }),
                });

                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(
                        `HTTP error! status: ${response.status}, message: ${errorText}`);
                }

                const result = await response.json();

            } catch (error) {

                // ユーザーにエラーを通知する（例: notie）
                // notie.alert({ type: 'error', text: '進捗の保存に失敗しました。', time: 2 });
            }
        }


        // サーバーから学習進捗データを取得する関数
        async function loadProgressFromServer() { // Make async
            if (!accid || !password) return;

            const detailsUrl = "/api/get_progress"; // Endpoint for detailed progress
            const summaryUrl = "/api/get"; // Endpoint for summary data (used for dashboard slide)

            try {
                const detailsResponse = await fetch(detailsUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        id: accid,
                        password: password,
                        problem_set: (() => {
                            // 範囲指定がある場合はそれを含める
                            const startParam = getParam("start");
                            const endParam = getParam("end");
                            if (startParam && endParam) {
                                return `${mondai}_${startParam}_${endParam}`;
                            }
                            return mondai;
                        })()
                    })
                });

                if (!detailsResponse.ok) {
                    if (detailsResponse.status === 404) {

                        answeredQuestions = new Set();
                        questionStats = new Map();
                        studyingQuestions = new Set(); // 初期化
                        localStorage.removeItem('current_question_index_' + mondai); // ローカルのインデックスもクリア
                        localStorage.removeItem('question_mode_' + mondai); // ローカルのモードもクリア
                    } else {
                        throw new Error(
                            `Error fetching progress details: ${detailsResponse.statusText}`);
                    }
                } else {
                    const detailsDataResult = await detailsResponse.json();
                    const detailsData = detailsDataResult.progress_details;
                    if (detailsData && Object.keys(detailsData).length > 0) {

                        applyProgressData(detailsData); // Apply the loaded details
                    } else {

                        answeredQuestions = new Set();
                        questionStats = new Map();
                        studyingQuestions = new Set(); // 初期化
                        localStorage.removeItem('current_question_index_' + mondai);
                        localStorage.removeItem('question_mode_' + mondai);
                    }
                }

                // 2. Fetch Summary Data (for dashboard slide total count)
                const summaryResponse = await fetch(summaryUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        id: accid,
                        password: password
                    })
                });

                if (!summaryResponse.ok) {

                } else {
                    const summaryDataResult = await summaryResponse.json();
                    const summary = summaryDataResult.progress_summary || {};
                    const p = summary[mondai] || {
                        learned: 0,
                        learning: 0,
                        unlearned: 0,
                        total: questions.length
                    };
                    // サーバーからの total があればそれを使う、なければ計算値
                    document.getElementById('total-questions').textContent = p.total ||
                        questions.length;
                }

                // 3. Update UI after potentially loading data
                updateStats(); // Recalculates stats based on loaded data
                selectQuestionMode(); // ローカルストレージ/サーバーからのモードとインデックスを反映してcurrentIndexを設定
                updateProgressDisplay(); // Updates score display

            } catch (error) {

                // Consider showing a user-friendly error message
                notie.alert({
                    type: 'error',
                    text: '進捗の読み込みに失敗しました。',
                    time: 2
                });
            }
        }

        // サーバーから取得した学習進捗データを適用する関数
        function applyProgressData(progressData) {

            answeredQuestions = new Set(progressData.answeredQuestions || []);
            maxStreak = progressData.maxStreak || 0;
            performanceHistory = progressData.performanceHistory || [];
            answerTimes = progressData.answerTimes || [];
            studyingQuestions = new Set(progressData.studyingQuestions || []); // studyingQuestionsも復元

            if (progressData.questionStats && typeof progressData.questionStats ===
                'object') {
                // questionStats の各エントリを数値キーの Map に変換
                questionStats = new Map();
                for (const key in progressData.questionStats) {
                    if (Object.hasOwnProperty.call(progressData.questionStats, key)) {
                        // キーを数値に変換、statsオブジェクトをそのまま値としてセット
                        questionStats.set(parseInt(key), progressData.questionStats[key]);
                    }
                }
            } else {
                questionStats = new Map();
            }

            // ユーザー設定の復元
            // 問題セット固有の設定を復元
            if (progressData.questionMode) {
                problemSettings.questionMode = progressData.questionMode;
            }

            if (progressData.currentQuestionIndex !== undefined) {
                // サーバーから取得したインデックスが有効範囲内かチェック
                const savedIndex = progressData.currentQuestionIndex;
                if (savedIndex >= 0 && savedIndex < questions.length) {
                    problemSettings.currentQuestionIndex = savedIndex;
                } else {
                    problemSettings.currentQuestionIndex = 0; // 無効なら0にリセット
                }
            }

            // グローバル設定も復元
            if (progressData.replaceMondai !== undefined) {
                globalSettings.replaceMondai = progressData.replaceMondai;
            }

            if (progressData.hardMode !== undefined) {
                globalSettings.hardMode = progressData.hardMode;
            }

            if (progressData.answerMode) {
                globalSettings.answerMode = progressData.answerMode;
            }

            // UIに設定を反映
            document.getElementById(problemSettings.questionMode + '-mode').checked =
                true;
            document.getElementById('replace-mondai').checked = globalSettings.replaceMondai;
            document.getElementById('hardmode').checked = globalSettings.hardMode;
            document.getElementById(globalSettings.answerMode + '-mode').checked = true;
            // ローカルストレージにも保存
            saveSettings();

            // correctCount, wrongCount, totalCount を questionStats から再計算
            correctCount = 0;
            wrongCount = 0;
            totalCount = 0;
            if (questionStats.size > 0) {
                answeredQuestions.forEach(index => {
                    const stats = questionStats.get(index);
                    if (stats) { // statsが存在する場合のみ計算
                        totalCount += stats.attempts || 0;
                        correctCount += stats.correctAnswers || 0;
                        wrongCount += (stats.attempts || 0) - (stats.correctAnswers || 0);
                    }
                });
            } else {
                // questionStatsがない場合（古いデータなど）はansweredQuestionsのサイズをtotalCountとする
                totalCount = answeredQuestions.size;
                // この場合、correct/wrongは0のまま（情報がないため）
            }

            // updateStats(); // この関数を呼び出す loadProgressFromServer の最後で updateStats が呼ばれるので、ここでは不要
        }


        document.getElementById('answer1').addEventListener('click', onAnswerClick);
        document.getElementById('answer2').addEventListener('click', onAnswerClick);
        document.getElementById('answer3').addEventListener('click', onAnswerClick);
        document.getElementById('answer4').addEventListener('click', onAnswerClick);

        // モーダルを初期化
        MicroModal.init({
            awaitOpenAnimation: true,
            awaitCloseAnimation: true
        });
        document.getElementById('settings-btn').addEventListener('click', function () {
            MicroModal.show('settings-modal');
        });

        // --- レーベンシュタイン距離計算関数 ---
        function calculateLevenshteinDistance(a, b) {
            if (a.length === 0) return b.length;
            if (b.length === 0) return a.length;

            const matrix = [];

            // increment along the first column of each row
            for (let i = 0; i <= b.length; i++) {
                matrix[i] = [i];
            }

            // increment each column in the first row
            for (let j = 0; j <= a.length; j++) {
                matrix[0][j] = j;
            }

            // Fill in the rest of the matrix
            for (let i = 1; i <= b.length; i++) {
                for (let j = 1; j <= a.length; j++) {
                    const cost = (b.charAt(i - 1) === a.charAt(j - 1)) ? 0 : 1;
                    matrix[i][j] = Math.min(
                        matrix[i - 1][j] + 1, // deletion
                        matrix[i][j - 1] + 1, // insertion
                        matrix[i - 1][j - 1] + cost // substitution
                    );
                }
            }

            return matrix[b.length][a.length];
        }
        // --- レーベンシュタイン距離計算関数 ここまで ---


        // 問題文と回答文を入れ換える機能
        const replaceMondaiCheckbox = document.getElementById('replace-mondai');

        // チェックボックスの変更イベント
        replaceMondaiCheckbox.addEventListener('change', async function () {
            globalSettings.replaceMondai = this.checked;
            saveSettings();

            // 現在の画面に合わせて更新
            populateWordList(); // 単語リスト再表示

            if (swiper.activeIndex === 1) {
                // 問題画面表示中なら問題も更新
                await showNextQuestion();
                notie.alert({
                    type: 'info',
                    text: this.checked ? '問題文と回答文を入れ替えました' : '問題文と回答文を元に戻しました',
                    time: 1.5
                });
            }

            swiper.update(); // スワイパー更新
        });

        // ハードモード機能
        const hardmodeCheckbox = document.getElementById('hardmode');

        // ハードモードチェックボックスの変更イベント
        hardmodeCheckbox.addEventListener('change', async function () {
            // 英単語以外の問題セットでハードモードを有効にしようとした場合は無効にする
            if (this.checked && !isProblemSetEnglish()) {
                notie.alert({
                    type: 'warning',
                    text: 'ハードモードは英単語問題でのみ利用可能です。',
                    time: 3
                });
                this.checked = false;
                globalSettings.hardMode = false;
            } else {
                globalSettings.hardMode = this.checked;
            }
            
            saveSettings();

            if (swiper.activeIndex === 1) {
                // 問題画面表示中なら問題も更新
                await showNextQuestion();
                notie.alert({
                    type: 'info',
                    text: this.checked ? 'ハードモードを有効にしました' : 'ハードモードを無効にしました',
                    time: 1.5
                });
            }
        });

        // 出題モード選択のイベントリスナー
        document.getElementById('random-mode').addEventListener('change', async function () {
            if (this.checked) {
                problemSettings.questionMode = 'random';
                saveSettings();
                selectQuestionMode(); // モード選択ロジックを呼び出してcurrentIndexを更新
                await showNextQuestion();
                updateProgressDisplay();
                notie.alert({
                    type: 'info',
                    text: 'ランダム出題モードに切り替えました',
                    time: 1.5
                });
            }
        });

        document.getElementById('sequential-mode').addEventListener('change', async function () {
            if (this.checked) {
                problemSettings.questionMode = 'sequential';
                saveSettings();
                selectQuestionMode(); // モード選択ロジックを呼び出してcurrentIndexを更新
                await showNextQuestion();
                updateProgressDisplay();
                notie.alert({
                    type: 'info',
                    text: '順番出題モードに切り替えました',
                    time: 1.5
                });
            }
        });

        document.querySelectorAll('input[name="answer-mode"]').forEach(radio => {
            radio.addEventListener('change', function () {
                const choiceArea = document.getElementById('choice-answers');
                const inputArea = document.getElementById('input-area');
                const handwritingArea = document.getElementById('handwriting-area');
                const wordArrangeArea = document.getElementById('word-arrange-area');
                const trueFalseArea = document.getElementById('true-false-area');

                globalSettings.answerMode = this.value;
                
                // 英単語並び替えモードが選択された場合のチェック
                if (this.value === 'word-arrange') {
                    // 問題データが読み込まれているかチェック
                    if (questions && questions.length > 0) {
                        const isEnglishSet = isProblemSetEnglish();
                        console.log('Word arrange mode selected. English set check:', isEnglishSet);
                        
                        if (!isEnglishSet) {
                            notie.alert({
                                type: 'warning',
                                text: '英単語並び替えモードは英単語問題でのみ利用可能です。4択モードに変更しました。',
                                time: 3
                            });
                            document.getElementById('choice-mode').checked = true;
                            globalSettings.answerMode = 'choice';
                        }
                    } else {
                        console.log('Questions not loaded yet, will check later');
                        // 問題データがまだ読み込まれていない場合は、後でチェックする
                        // loadQuestions完了後にcheckAndControlEnglishOnlyFeaturesが呼ばれる
                    }
                }
                
                saveSettings();

                // すべてのエリアを非表示にする
                choiceArea.style.display = 'none';
                inputArea.style.display = 'none';
                handwritingArea.style.display = 'none';
                wordArrangeArea.style.display = 'none';
                trueFalseArea.style.display = 'none';

                if (globalSettings.answerMode === 'choice') {
                    choiceArea.style.display = 'block';
                } else if (globalSettings.answerMode === 'input') {
                    inputArea.style.display = 'block';
                    document.getElementById('text-answer').focus();
                } else if (globalSettings.answerMode === 'handwriting') {
                    handwritingArea.style.display = 'block';
                    // 手書きモード初期化処理（必要なら）
                } else if (globalSettings.answerMode === 'word-arrange') {
                    wordArrangeArea.style.display = 'block';
                } else if (globalSettings.answerMode === 'true-false') {
                    trueFalseArea.style.display = 'block';
                }
            });
        });
        // テキスト回答送信
        document.getElementById('submit-text-answer').addEventListener('click',
            function () {
                const answer = document.getElementById('text-answer').value.trim();
                if (answer) {
                    checkTextAnswer(answer);
                }
            });

        // テキスト回答のEnterキー処理
        document.getElementById('text-answer').addEventListener('keypress', function (e) {
            if (e.key === 'Enter') {
                const answer = this.value.trim();
                if (answer) {
                    checkTextAnswer(answer);
                }
            }
        });

        // 正解時の処理 (入力/手書きモード用)
        async function handleCorrectAnswerInput() {
            if (typeof start === 'undefined' || start === null) {
                start = performance.now();
            }
            const endTime = performance.now();
            const timeTaken = endTime - start;
            answerTimes.push(timeTaken);
            start = null;

            if (!questionStats.has(currentIndex)) {
                questionStats.set(currentIndex, {
                    attempts: 0,
                    correctAnswers: 0,
                    averageTime: 0,
                    isLongTime: false,
                    isWrong: false
                });
            }

            const stats = questionStats.get(currentIndex);
            stats.attempts++;
            stats.averageTime = ((stats.averageTime || 0) * (stats.attempts - 1) +
                timeTaken) / stats.attempts;
            stats.isWrong = false

            answeredQuestions.add(currentIndex);
            totalCount++;
            correctCount++;
            renzokuseikai++;

            if (renzokuseikai > maxStreak) {
                maxStreak = renzokuseikai;
            }

            stats.correctAnswers = (stats.correctAnswers || 0) + 1;
            const avgTime = calculateAverageTime();
            const isLongTime = timeTaken / 1000 > Math.max(5, avgTime * 1.5);
            stats.isLongTime = isLongTime || stats.isLongTime;

            // 正解回数2回以上、かつ時間がかかっていない場合に学習中から外す
            if (stats.correctAnswers >= 2 && !stats.isLongTime) {
                studyingQuestions.delete(currentIndex);
            } else if (stats.correctAnswers >= 1 && isLongTime) {
                studyingQuestions.add(currentIndex); // 時間がかかったら学習中に戻す
            }


            notie.alert({
                type: 1,
                text: '正解',
                time: 1
            });
            updateProgressDisplay();
            updateStats();

            // 入力フィールド/キャンバスをクリア
            document.getElementById('text-answer').value = '';
            if (window.clearCanvas) clearCanvas(); // write.js の関数があれば呼ぶ

            sendScore("add_correct", accid, password);
            await saveProgressToServer(); // 進捗保存

            nextIndex();
            await showNextQuestion();
        }


        // 不正解時の処理 (入力/手書きモード用)
        async function handleWrongAnswerInput(userAnswer, correctAnswer) {
            if (typeof start === 'undefined' || start === null) {
                start = performance.now();
            }
            const endTime = performance.now();
            const timeTaken = endTime - start;
            answerTimes.push(timeTaken);
            start = null; // タイマーリセット

            if (!questionStats.has(currentIndex)) {
                questionStats.set(currentIndex, {
                    attempts: 0,
                    correctAnswers: 0,
                    averageTime: 0,
                    isLongTime: false,
                    isWrong: false
                });
            }

            const stats = questionStats.get(currentIndex);
            stats.attempts++;
            stats.averageTime = ((stats.averageTime || 0) * (stats.attempts - 1) +
                timeTaken) / stats.attempts;
            stats.isWrong = true; // 不正解フラグ

            answeredQuestions.add(currentIndex);
            totalCount++;
            wrongCount++;
            renzokuseikai = 0;
            studyingQuestions.add(currentIndex); // 不正解なら必ず学習中リストへ

            const avgTime = calculateAverageTime();
            const isLongTime = timeTaken / 1000 > Math.max(5, avgTime * 1.5);
            stats.isLongTime = isLongTime || stats.isLongTime; // 時間がかかったかも記録

            notie.force({
                type: 'error',
                text: '<div class="popup">正しい回答: ' + correctAnswer + '<br>あなたの回答: ' +
                    userAnswer + '</div>',
                buttonText: '私は間違えたことを深くお詫び、反省することを誓います。',
                callback: async function () { // Make callback async
                    // 入力フィールド/キャンバスはクリアしない（間違いを確認できるように）
                    // document.getElementById('text-answer').value = '';
                    // if (window.clearCanvas) clearCanvas();

                    updateProgressDisplay();
                    updateStats();

                    sendScore("add_bad", accid, password);
                    await saveProgressToServer(); // 進捗保存

                    // 不正解時は同じ問題を表示 (nextIndexを呼ばない)
                    await showNextQuestion();
                }
            });
        }


        // テキスト回答の正誤チェック
        function checkTextAnswer(answer) {
            const isReversed = globalSettings.replaceMondai;
            const correctAnswer = isReversed ? questions[currentIndex].description :
                questions[currentIndex].word;

            // 完全一致で比較
            if (answer === correctAnswer) {
                handleCorrectAnswerInput();
            } else {
                // ひらがな・カタカナ、全角・半角の違いなどを許容する場合はここで処理を追加
                // 例: normalizeAnswer(answer) === normalizeAnswer(correctAnswer)
                handleWrongAnswerInput(answer, correctAnswer);
            }
        }


        // 手書き回答の送信処理 (write.js側で checkHandwritingAnswer を呼ぶ想定)
        function checkHandwritingAnswer(handwritingResult) {
            const isReversed = globalSettings.replaceMondai;
            const correctAnswer = isReversed ? questions[currentIndex].description :
                questions[currentIndex].word;

            // 手書き認識結果 (handwritingResult) と正解 (correctAnswer) を比較
            // 認識結果が複数候補ある場合は、いずれかが一致すれば正解とするなどの処理が必要
            // ここでは単純に最初の候補と比較する例
            if (handwritingResult && handwritingResult.length > 0 && handwritingResult[0] ===
                correctAnswer) {
                handleCorrectAnswerInput();
            } else {
                handleWrongAnswerInput(handwritingResult ? handwritingResult.join(', ') :
                    '認識失敗', correctAnswer);
            }
        }

        // 英単語並び替えモードのセットアップ
        async function setupWordArrangeMode(correctAnswer) {
            console.log('Setting up word arrange mode for:', correctAnswer);
            
            // 正解の文章を保存（デフォルト値を設定）
            window.correctSentence = correctAnswer;
            window.arrangedWords = [];
            
            // シャッフルされた単語を表示するコンテナを取得
            const shuffledContainer = document.getElementById('shuffled-words');
            const arrangedContainer = document.getElementById('arranged-words');
            
            if (!shuffledContainer || !arrangedContainer) {
                console.error('Word arrange containers not found');
                return;
            }
            
            // ハードモードの処理を参考に、英単語から文章を取得
            try {
                const response = await fetch('/api/get/sentences', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        words: [correctAnswer]
                    })
                });

                if (response.ok) {
                    const sentenceData = await response.json();
                    
                    if (sentenceData.results && sentenceData.results[correctAnswer] &&
                        sentenceData.results[correctAnswer].length > 0) {
                        const sentences = sentenceData.results[correctAnswer];
                        const selectedSentence = sentences[Math.floor(Math.random() * sentences.length)];
                        const parts = selectedSentence.split("|");
                        window.correctSentence = parts[1] || selectedSentence;
                        window.japaneseText = parts[0] || null;
                        console.log('Got sentence from API:', window.correctSentence);
                        console.log('Japanese text:', window.japaneseText);

                    } else {
                        // 文章が見つからない場合は、正解の単語を使った簡単な文を作成
                        window.correctSentence = `This is a ${correctAnswer}.`;
                        console.log('Using fallback sentence:', window.correctSentence);
                    }
                } else {
                    throw new Error(`API request failed with status ${response.status}`);
                }
            } catch (error) {
                console.error('Error fetching sentences:', error);
                // エラーの場合は単語そのものまたは簡単な文を使用
                if (correctAnswer.includes(' ')) {
                    window.correctSentence = correctAnswer;
                } else {
                    window.correctSentence = `This is a ${correctAnswer}.`;
                }
                console.log('Using error fallback sentence:', window.correctSentence);
            }
            
            // 文章を単語に分割（句読点も含める）
            const words = window.correctSentence.match(/\b\w+\b|[.,!?;]/g) ||
                         window.correctSentence.split(/\s+/).filter(word => word.trim() !== '');
            
            console.log('Words to arrange:', words);
            
            if (words.length === 0) {
                console.error('No words found to arrange');
                return;
            }
            
            // 単語をシャッフル
            const shuffledWords = [...words].sort(() => Math.random() - 0.5);

            // シャッフルされた単語を表示
            shuffledContainer.innerHTML = '';

            shuffledWords.forEach((word, index) => {
                const wordChip = document.createElement('button');
                const isPunctuation = /^[.,!?;:]$/.test(word);
                wordChip.className = isPunctuation ? 'word-chip punctuation' : 'word-chip';
                wordChip.textContent = word;
                wordChip.dataset.word = word;
                wordChip.dataset.originalIndex = index;
                wordChip.onclick = () => moveWordToArranged(wordChip);
                setupDragAndDrop(wordChip);
                shuffledContainer.appendChild(wordChip);
            });

            // 並び替えエリアをリセット
            arrangedContainer.innerHTML = '<div class="arranged-placeholder">ここに単語をタップして配置</div>';
            
            // 問題文を更新
            const questionElement = document.getElementById('question');
            if (window.japaneseText) {
                questionElement.innerHTML =
                    `<div>次の日本語を英語に直して、正しい語順に並び替えてください：</div><br><div><em>${window.japaneseText}</em></div>`;
            } else {
                questionElement.innerHTML =
                    `<div>次の英文を正しい語順に並び替えてください：</div><br><div><em>${window.correctSentence}</em></div>`;
            }
        }

        // 単語を並び替えエリアに移動
        function moveWordToArranged(wordChip) {
            const arrangedContainer = document.getElementById('arranged-words');
            const placeholder = arrangedContainer.querySelector('.arranged-placeholder');

            // プレースホルダーを削除
            if (placeholder) {
                placeholder.remove();
            }

            // 単語を並び替えエリアに追加
            const arrangedChip = wordChip.cloneNode(true);
            const isPunctuation = /^[.,!?;:]$/.test(arrangedChip.textContent);
            arrangedChip.className = isPunctuation ? 'word-chip arranged punctuation' : 'word-chip arranged';
            arrangedChip.onclick = () => moveWordBackToShuffled(arrangedChip);
            setupDragAndDrop(arrangedChip);
            arrangedContainer.appendChild(arrangedChip);

            // 元の単語を削除
            wordChip.remove();

            // 配置された単語を記録
            window.arrangedWords.push(arrangedChip.dataset.word);
        }

        // 単語をシャッフルエリアに戻す
        function moveWordBackToShuffled(arrangedChip) {
            const shuffledContainer = document.getElementById('shuffled-words');
            const arrangedContainer = document.getElementById('arranged-words');

            // 単語をシャッフルエリアに戻す
            const shuffledChip = arrangedChip.cloneNode(true);
            const isPunctuation = /^[.,!?;:]$/.test(shuffledChip.textContent);
            shuffledChip.className = isPunctuation ? 'word-chip punctuation' : 'word-chip';
            shuffledChip.onclick = () => moveWordToArranged(shuffledChip);
            setupDragAndDrop(shuffledChip);
            shuffledContainer.appendChild(shuffledChip);

            // 並び替えエリアから削除
            arrangedChip.remove();

            // 記録から削除
            const wordIndex = window.arrangedWords.indexOf(arrangedChip.dataset.word);
            if (wordIndex > -1) {
                window.arrangedWords.splice(wordIndex, 1);
            }

            // プレースホルダーを表示するかチェック
            if (window.arrangedWords.length === 0) {
                arrangedContainer.innerHTML =
                    '<div class="arranged-placeholder">ここに単語をタップして配置</div>';
            }
        }

        // 並び替え回答をリセット
        async function clearWordArrangement() {
            const isReversed = globalSettings.replaceMondai;
            const correctAnswer = isReversed ? questions[currentIndex].description :
                questions[currentIndex].word;
            await setupWordArrangeMode(correctAnswer);
        }

        // 並び替え回答を送信
        function submitWordArrangement() {
            if (!window.arrangedWords || window.arrangedWords.length === 0) {
                alert('単語を配置してください');
                return;
            }

            const userAnswer = window.arrangedWords.join(' ');
            const correctAnswer = window.correctSentence || questions[currentIndex].word;

            // 句読点を無視した比較
            const normalizeText = (text) => {
                return text.replace(/[.,!?;]/g, '').replace(/s+/g, ' ').trim().toLowerCase();
            };

            const isCorrect = normalizeText(userAnswer) === normalizeText(correctAnswer);

            if (isCorrect) {
                handleCorrectAnswerInput();
            } else {
                handleWrongAnswerInput(userAnswer, correctAnswer);
            }
        }

        // ドラッグアンドドロップ機能のセットアップ
        function setupDragAndDrop(element) {
            // 既存のイベントリスナーを削除（重複防止）
            element.removeEventListener('dragstart', handleDragStart);
            element.removeEventListener('dragend', handleDragEnd);
            element.removeEventListener('dragover', handleDragOver);
            element.removeEventListener('drop', handleDrop);
            element.removeEventListener('dragenter', handleDragEnter);
            element.removeEventListener('dragleave', handleDragLeave);
            
            element.draggable = true;
            
            element.addEventListener('dragstart', handleDragStart);
            element.addEventListener('dragend', handleDragEnd);
            element.addEventListener('dragover', handleDragOver);
            element.addEventListener('drop', handleDrop);
            element.addEventListener('dragenter', handleDragEnter);
            element.addEventListener('dragleave', handleDragLeave);
        }

        let draggedElement = null;
        let dragStartContainer = null;

        function handleDragStart(e) {
            draggedElement = e.target;
            dragStartContainer = e.target.parentElement;
            e.target.classList.add('dragging');
            
            // データ転送の設定
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/html', e.target.outerHTML);
        }

        function handleDragEnd(e) {
            e.target.classList.remove('dragging');
            
            // すべての視覚的フィードバックをクリア
            document.querySelectorAll('.word-chip').forEach(chip => {
                chip.classList.remove('drag-over', 'insert-before', 'insert-after');
            });
            document.querySelectorAll('.shuffled-words-container, .arranged-words-container').forEach(container => {
                container.classList.remove('drag-over');
            });
            
            draggedElement = null;
            dragStartContainer = null;
        }

        function handleDragOver(e) {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';
            
            const container = e.target.closest('.shuffled-words-container, .arranged-words-container');
            if (container) {
                container.classList.add('drag-over');
            }
            
            // 並び替えエリア内での位置指示
            if (e.target.classList.contains('word-chip') &&
                e.target.closest('.arranged-words-container')) {
                const rect = e.target.getBoundingClientRect();
                const midpoint = rect.left + rect.width / 2;
                
                // マウス位置に応じて挿入位置を示す
                if (e.clientX < midpoint) {
                    e.target.classList.add('insert-before');
                    e.target.classList.remove('insert-after');
                } else {
                    e.target.classList.add('insert-after');
                    e.target.classList.remove('insert-before');
                }
            }
        }

        function handleDragEnter(e) {
            e.preventDefault();
        }

        function handleDragLeave(e) {
            const container = e.target.closest('.shuffled-words-container, .arranged-words-container');
            if (container && !container.contains(e.relatedTarget)) {
                container.classList.remove('drag-over');
            }
            
            if (e.target.classList.contains('word-chip')) {
                e.target.classList.remove('insert-before', 'insert-after');
            }
        }

        function handleDrop(e) {
            e.preventDefault();
            
            if (!draggedElement) return;
            
            const targetContainer = e.target.closest('.shuffled-words-container, .arranged-words-container');
            const targetElement = e.target.closest('.word-chip');
            
            if (!targetContainer) return;
            
            // 同じ要素にドロップした場合は何もしない
            if (draggedElement === targetElement) return;
            
            const isTargetArranged = targetContainer.classList.contains('arranged-words-container');
            const isDraggedFromArranged = draggedElement.classList.contains('arranged');
            
            // プレースホルダーを削除
            const placeholder = targetContainer.querySelector('.arranged-placeholder');
            if (placeholder) {
                placeholder.remove();
            }
            
            if (isTargetArranged) {
                // 並び替えエリア内での移動か、外部からの移動かを判定
                if (isDraggedFromArranged && targetElement && targetElement.classList.contains('word-chip')) {
                    // 並び替えエリア内での順序変更
                    if (targetElement.classList.contains('insert-before')) {
                        targetContainer.insertBefore(draggedElement, targetElement);
                    } else {
                        targetContainer.insertBefore(draggedElement, targetElement.nextSibling);
                    }
                    // arrangedWords配列を更新
                    updateArrangedWordsArray();
                } else {
                    // シャッフルエリアから並び替えエリアへの移動
                    const newChip = document.createElement('button');
                    const isPunctuation = /^[.,!?;:]$/.test(draggedElement.textContent);
                    newChip.className = isPunctuation ? 'word-chip arranged punctuation' : 'word-chip arranged';
                    newChip.textContent = draggedElement.textContent;
                    newChip.dataset.word = draggedElement.dataset.word;
                    newChip.dataset.originalIndex = draggedElement.dataset.originalIndex;
                    newChip.onclick = () => moveWordBackToShuffled(newChip);
                    setupDragAndDrop(newChip);
                    
                    if (targetElement && targetElement.classList.contains('word-chip')) {
                        // 特定の位置に挿入
                        if (targetElement.classList.contains('insert-before')) {
                            targetContainer.insertBefore(newChip, targetElement);
                        } else {
                            targetContainer.insertBefore(newChip, targetElement.nextSibling);
                        }
                    } else {
                        // 最後に追加
                        targetContainer.appendChild(newChip);
                    }
                    
                    // arrangedWords配列を更新
                    updateArrangedWordsArray();
                    
                    // 元の要素を削除（ドラッグ元から）
                    draggedElement.remove();
                }
            } else {
                // シャッフルエリアにドロップ（戻す）
                if (isDraggedFromArranged) {
                    const newChip = document.createElement('button');
                    const isPunctuation = /^[.,!?;:]$/.test(draggedElement.textContent);
                    newChip.className = isPunctuation ? 'word-chip punctuation' : 'word-chip';
                    newChip.textContent = draggedElement.textContent;
                    newChip.dataset.word = draggedElement.dataset.word;
                    newChip.dataset.originalIndex = draggedElement.dataset.originalIndex;
                    newChip.onclick = () => moveWordToArranged(newChip);
                    setupDragAndDrop(newChip);
                    targetContainer.appendChild(newChip);
                    
                    // arrangedWords配列から削除
                    const wordIndex = window.arrangedWords.indexOf(draggedElement.dataset.word);
                    if (wordIndex > -1) {
                        window.arrangedWords.splice(wordIndex, 1);
                    }
                    
                    draggedElement.remove();
                    
                    // プレースホルダーをチェック
                    checkAndAddPlaceholder();
                }
            }
            
            // 視覚的フィードバックをクリア
            document.querySelectorAll('.word-chip').forEach(chip => {
                chip.classList.remove('insert-before', 'insert-after');
            });
            document.querySelectorAll('.shuffled-words-container, .arranged-words-container').forEach(container => {
                container.classList.remove('drag-over');
            });
        }

        // 並び替えられた単語の配列を更新
        function updateArrangedWordsArray() {
            const arrangedContainer = document.getElementById('arranged-words');
            const chips = arrangedContainer.querySelectorAll('.word-chip.arranged');
            window.arrangedWords = Array.from(chips).map(chip => chip.dataset.word);
        }

        // プレースホルダーが必要かチェックして追加
        function checkAndAddPlaceholder() {
            const arrangedContainer = document.getElementById('arranged-words');
            const chips = arrangedContainer.querySelectorAll('.word-chip.arranged');
            
            if (chips.length === 0) {
                arrangedContainer.innerHTML = '<div class="arranged-placeholder">ここに単語をタップして配置</div>';
            }
        }

        // コンテナにもドロップイベントを設定
        document.addEventListener('DOMContentLoaded', function() {
            const shuffledContainer = document.getElementById('shuffled-words');
            const arrangedContainer = document.getElementById('arranged-words');
            
            [shuffledContainer, arrangedContainer].forEach(container => {
                if (container) {
                    container.addEventListener('dragover', handleDragOver);
                    container.addEventListener('drop', handleDrop);
                    container.addEventListener('dragenter', handleDragEnter);
                    container.addEventListener('dragleave', handleDragLeave);
                }
            });
        });

        // ○×問題モードのセットアップ
        function setupTrueFalseMode(question) {
            // 問題データに trueFalseAnswer プロパティがあるかチェック
            if (question.trueFalseAnswer !== undefined) {
                // 明示的に○×の正解が設定されている場合
                window.trueFalseCorrectAnswer = question.trueFalseAnswer;
            } else {
                // 設定されていない場合はランダムで決定（デモ用）
                window.trueFalseCorrectAnswer = Math.random() < 0.5;
            }
        }

        // ○×問題の回答処理
        function submitTrueFalseAnswer(userAnswer) {
            const isCorrect = userAnswer === window.trueFalseCorrectAnswer;

            if (isCorrect) {
                handleCorrectAnswerInput();
            } else {
                const answerText = userAnswer ? '○ (正しい)' : '× (間違い)';
                const correctText = window.trueFalseCorrectAnswer ? '○ (正しい)' : '× (間違い)';
                handleWrongAnswerInput(answerText, correctText);
            }
        }


        document.addEventListener('DOMContentLoaded', function () {
            if (getParam("tangolist") === 'true') {
                swiper.slideTo(2);

                const url = new URL(window.location.href);
                url.searchParams.delete('tangolist');
                window.history.replaceState({}, document.title, url);
            }

            // ローカルストレージから設定を読み込み、UIに反映
            loadSettings();

            // 回答モードの表示を切り替える
            const answerModeRadio = document.getElementById(globalSettings.answerMode +
                '-mode');
            if (answerModeRadio) {
                answerModeRadio.dispatchEvent(new Event('change'));
            }

            //タイトルの変更
            document.title = `Quizbox - ${getParam("id")}`;
        });

        // 復習モード開始ボタンのイベントリスナー
        document.getElementById('start-review-btn').addEventListener('click', async function () {
            reviewQuestions = Array.from(studyingQuestions);
            if (reviewQuestions.length === 0) {
                notie.alert({
                    type: 'info',
                    text: '復習する問題はありません。',
                    time: 2
                });
                return;
            }

            isInReviewMode = true;
            reviewStreaks = {};
            reviewQuestions.forEach(index => reviewStreaks[index] = 0); // Streaks初期化

            // 復習モードの最初の問題を設定 (ランダムに)
            if (reviewQuestions.length > 0) {
                currentIndex = reviewQuestions[Math.floor(Math.random() * reviewQuestions.length)];
            } else {
                // 念のため復習対象がない場合の処理
                isInReviewMode = false;
                notie.alert({
                    type: 'info',
                    text: 'エラー: 復習対象がありません。',
                    time: 2
                });
                return;
            }


            document.getElementById('review-mode-indicator').style.display = 'block';
            document.getElementById('exit-review-btn').style.display = 'block';
            document.getElementById('review-count').textContent = reviewQuestions.length;

            swiper.slideTo(1); // クイズ画面へ移動
            await showNextQuestion();
            updateProgressDisplay(); // 進捗表示も更新
            notie.alert({
                type: 'info',
                text: '復習モードを開始します。',
                time: 1.5
            });
            // 復習モード開始時もタイマー開始
            start = performance.now();
        });

        // 通常モードに戻るボタンのイベントリスナー
        document.getElementById('exit-review-btn').addEventListener('click', async function () {
            isInReviewMode = false;
            document.getElementById('review-mode-indicator').style.display = 'none';
            document.getElementById('exit-review-btn').style.display = 'none';
            notie.alert({
                type: 'info',
                text: '通常モードに戻りました。',
                time: 1.5
            });
            saveProgressToServer(); // 復習モード終了時に進捗保存
            selectQuestionMode(); // 通常のモード選択ロジックを再実行
            await showNextQuestion();
            updateProgressDisplay();
            // 通常モードに戻った時もタイマー開始
            start = performance.now();
        });

        // 英単語並び替えモードのイベントリスナー
        document.getElementById('clear-arrange').addEventListener('click',
            clearWordArrangement);
        document.getElementById('submit-arrange').addEventListener('click',
            submitWordArrangement);

        // ○×問題モードのイベントリスナー
        document.getElementById('true-btn').addEventListener('click', function () {
            submitTrueFalseAnswer(true);
        });

        document.getElementById('false-btn').addEventListener('click', function () {
            submitTrueFalseAnswer(false);
        });
    </script>
</body>

</html>