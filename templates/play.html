<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>4択クイズ</title>
    <link href="https://cdn.jsdelivr.net/npm/swiper@11.2.8/swiper-bundle.min.css" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/swiper@11.2.8/swiper-bundle.min.js"></script>
    <link rel="stylesheet" href="./style.css">
    <link rel="preload" href="https://fonts.googleapis.com/earlyaccess/notosansjapanese.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
    <noscript><link rel="stylesheet" href="https://fonts.googleapis.com/earlyaccess/notosansjapanese.css"></noscript>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css">
    <link rel="stylesheet" href="../../modal.css">
    <link href="https://cdn.jsdelivr.net/npm/notie@4.3.1/dist/notie.min.css" rel="stylesheet">
    <link rel="stylesheet" href="./word-dictionary.css">
</head>

<body>
    <a href="javascript:pageback()" class="back"></a>
    <a href="javascript:void(0);" id="settings-btn" class="settings-btn">
        <i class="fas fa-cog"></i>
    </a>
    <div class="swiper-container">
        <div class="swiper-wrapper">
            <div class="swiper-slide slide1">
                <div class="resultbox">
                    <div class="resultbox1">
                        <div class="progress-title">
                            <i class="fas fa-book-open"></i>学習進捗
                        </div>
                        <div id="progress-stats">
                            <div>
                                <i class="fas fa-tasks"></i>総問題数:
                                <span id="total-questions">0</span>
                            </div>
                            <div>
                                <i class="fas fa-check-circle"></i>学習済み:
                                <span id="answered-questions">0</span>
                            </div>
                            <div>
                                <i class="fas fa-smile"></i>正解:
                                <span id="correct-answers">0</span>
                            </div>
                            <div>
                                <i class="fas fa-times-circle"></i>不正解:
                                <span id="wrong-answers">0</span>
                            </div>
                            <div>
                                <i class="fas fa-chart-pie"></i>進捗率:
                                <span id="progress-percentage">0</span>%
                                <div class="progress-bar-container">
                                    <div class="progress-bar" id="progress-bar" style="width: 0%">
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="resultbox2">
                        <div class="stats-title">
                            <i class="fas fa-chart-bar"></i>統計情報
                        </div>
                        <div id="performance-stats">
                            <div>
                                <i class="fas fa-percentage"></i>平均正解率:
                                <span id="avg-accuracy">0</span>%
                            </div>
                            <div>
                                <i class="fas fa-trophy"></i>最高連続正解:
                                <span id="max-streak">0</span>
                            </div>
                            <div>
                                <i class="fas fa-fire"></i>現在の連続正解:
                                <span id="current-streak">0</span>
                            </div>
                            <div>
                                <i class="fas fa-stopwatch"></i>平均解答時間:
                                <span id="avg-time">0</span>秒
                            </div>
                        </div>
                    </div>
                    <div class="resultbox3">
                        <div class="study-title">
                            <i class="fas fa-exclamation-circle"></i>学習中の問題
                        </div>
                        <ul id="study-list"></ul>
                        <button id="start-review-btn" class="review-btn">間違えた問題を復習する</button>
                    </div>
                    <div class="resultbox4">
                        <canvas id="performance-chart"></canvas>
                    </div>
                </div>
            </div>
            <div class="swiper-slide slide2">
                <div class="main">
                    <div id="review-mode-indicator" class="review-mode-indicator">復習モード中 (残り
                        <span id="review-count">0</span>問)
                    </div>
                    <div class="title">
                        <div id="question">
                        </div>
                    </div>
                    <ul class="sp" id="choice-answers">
                        <li>
                            <button id="answer1"></button>
                        </li>
                        <li>
                            <button id="answer2"></button>
                        </li>
                        <li>
                            <button id="answer3"></button>
                        </li>
                        <li>
                            <button id="answer4"></button>
                        </li>
                    </ul>
                    <div id="input-area" style="display: none;" class="no-swiping">
                        <input type="text" id="text-answer" placeholder="回答を入力">
                        <button id="submit-text-answer">回答</button>
                    </div>
                    <div id="handwriting-area" style="display: none;" class="no-swiping">
                        <div class="canvas-container no-swiping">
                            <canvas id="handwriting-canvas" width="400" height="200" class="no-swiping"></canvas>
                        </div>
                        <div class="handwriting-controls no-swiping">
                            <button id="clear-canvas" class="handwriting-btn">クリア</button>
                            <button id="submit-answer" class="handwriting-btn">回答する</button>
                        </div>
                    </div>
                    <!-- 英単語並び替えモード -->
                    <div id="word-arrange-area" style="display: none;" class="no-swiping">
                        <div class="word-arrange-instruction">単語を正しい順序でタップして文章を完成させてください
                        </div>
                        <div id="shuffled-words" class="shuffled-words-container">
                        </div>
                        <div id="arranged-words" class="arranged-words-container">
                            <div class="arranged-placeholder">ここに単語をタップして配置
                            </div>
                        </div>
                        <div class="word-arrange-controls">
                            <button id="clear-arrange" class="arrange-btn">リセット</button>
                            <button id="submit-arrange" class="arrange-btn">回答</button>
                        </div>
                    </div>
                    <!-- ○×問題モード -->
                    <div id="true-false-area" style="display: none;" class="no-swiping">
                        <div class="true-false-instruction">この問題文は正しいですか？
                        </div>
                        <div class="true-false-buttons">
                            <button id="true-btn" class="tf-btn true-btn">○ (正しい)</button>
                            <button id="false-btn" class="tf-btn false-btn">× (間違い)</button>
                        </div>
                    </div>
                </div>
                <div id="score">回答数: 0 正解数: 0 不正解数: 0 連続正解数:0 正答率: 0%
                </div>
                <button id="exit-review-btn" class="exit-review-btn">通常モードに戻る</button>
        </div>
        <div class="swiper-slide slide3">
            <div class="tangolist">
                <h1>単語リスト</h1>
                <div class="search-container">
                    <input type="text" class="searchbox" placeholder="検索" oninput="filterWords()">
                    <i class="fas fa-search search-icon"></i>
                    <div class="filter-options">
                        <select id="answerFilter" onchange="filterWords()">
                            <option value="all">すべての問題</option>
                            <option value="unanswered">未回答の問題</option>
                            <option value="correct">正解した問題</option>
                            <option value="incorrect">間違えた問題</option>
                        </select>
                    </div>
                </div>
                <ul id="wordList" class="custom-list"></ul>
            </div>
        </div>
    </div>
    <div class="swiper-button-next">
    </div>
    <div class="swiper-button-prev">
    </div>
    </div>
    <div class="modal micromodal-slide" id="modal-1" aria-hidden="true">
        <div class="modal__overlay" tabindex="-1" data-micromodal-close>
            <div class="modal__container" role="dialog" aria-modal="true" aria-labelledby="modal-1-title">
                <main class="modal__content" id="modal-1-content">
                    <div id="result-message" class="result-message">
                    </div>
                </main>
                <footer class="modal__footer modal__footer-centered">
                    <button class="modal__btn" data-micromodal-close
                        aria-label="Close this dialog window">私は間違えたことを深くお詫び、反省することを誓います。</button>
                </footer>
            </div>
        </div>
    </div>
    <div class="modal micromodal-slide" id="settings-modal" aria-hidden="true">
        <div class="modal__overlay" tabindex="-1" data-micromodal-close>
            <div class="modal__container" role="dialog" aria-modal="true" aria-labelledby="settings-modal-title">
                <header class="modal__header modal__header-centered">
                    <h2 id="settings-modal-title">設定</h2>
                </header>
                <main class="modal__content" id="settings-modal-content">
                    <div class="settings-section">
                        <h3>出題方法</h3>
                        <div class="settings-option">
                            <input type="checkbox" name="replace-mondai" id="replace-mondai">
                            <label for="replace-mondai">問題文と回答文を入れ換える</label>
                        </div>
                        <div class="settings-option">
                            <input type="checkbox" name="hardmode" id="hardmode">
                            <label for="hardmode">ハードモード</label>
                        </div>
                        <h3>出題順序</h3>
                        <div class="settings-option">
                            <input type="radio" id="random-mode" name="question-mode" value="random" checked>
                            <label for="random-mode">ランダムに出題</label>
                        </div>
                        <div class="settings-option">
                            <input type="radio" id="sequential-mode" name="question-mode" value="sequential">
                            <label for="sequential-mode">1問目から順に出題</label>
                        </div>
                        <h3>回答モード</h3>
                        <div class="settings-option">
                            <input type="radio" id="choice-mode" name="answer-mode" value="choice" checked>
                            <label for="choice-mode">4択モード</label>
                        </div>
                        <div class="settings-option">
                            <input type="radio" id="input-mode" name="answer-mode" value="input">
                            <label for="input-mode">入力モード</label>
                        </div>
                        <div class="settings-option">
                            <input type="radio" id="handwriting-mode" name="answer-mode" value="handwriting">
                            <label for="handwriting-mode">手書きモード(Beta)</label>
                        </div>
                        <div class="settings-option">
                            <input type="radio" id="word-arrange-mode" name="answer-mode" value="word-arrange">
                            <label for="word-arrange-mode">英単語並び替えモード</label>
                        </div>
                        <h3>発音機能</h3>
                        <div class="settings-option">
                            <input type="checkbox" name="pronunciation" id="pronunciation">
                            <label for="pronunciation">正解時に英単語の発音を再生する</label>
                        </div>
                        <h3>リスニングモード</h3>
                        <a href="javascript:window.location.replace(`/listening?id=${encodeURIComponent(mondai)}`);"
                            style="color: black;text-decoration:none;">リスニングモードに移動</a>
                    </div>
                </main>
                <footer class="modal__footer" style="text-align: center;">
                    <button class="modal__btn" data-micromodal-close aria-label="Close this dialog window">閉じる</button>
                </footer>
            </div>
        </div>
    </div>
    <audio id="audioPlayer" class="hidden-player"></audio>
    <script src="https://cdn.jsdelivr.net/npm/micromodal@0.6.1/dist/micromodal.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/notie@4.3.1/dist/notie.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/js-cookie@3.0.5/dist/js.cookie.min.js"></script>
    <script src="./search.js"></script>
    <script src="./write.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js" defer></script>
    <script>
        // Swiperの初期化
        const swiper = new Swiper(".swiper-container", {
            direction: "horizontal",
            loop: false,
            initialSlide: 1,
            navigation: {
                nextEl: ".swiper-button-next",
                prevEl: ".swiper-button-prev",
            },
            mousewheel: false,
            noSwiping: true,
            noSwipingClass: "no-swiping",
        });

        let start;

        swiper.on('slideChangeTransitionEnd', function () {
            if (swiper.activeIndex === 1) {
                start = performance.now();
            }
            document.querySelector('.swiper-button-next').style.display = 'block';
            document.querySelector('.swiper-button-prev').style.display = 'block';
        });


        function getParam(name, url) {
            if (!url) url = window.location.href;
            name = name.replace(/\\/g, "\\\\").replace(/[\[\]]/g, "\\$&");
            var regex = new RegExp("[?&]" + name + "(=([^&#]*)|&|#|$)"),
                results = regex.exec(url);
            if (!results) return null;
            if (!results[2]) return '';
            return decodeURIComponent(results[2].replace(/\+/g, " "));
        }

        let mondai = getParam("id");
        let isCustom = false;
        let accid = Cookies.get('id');
        let password = Cookies.get('password');

        if (mondai == null) {
            let mondaiuserid = getParam("userid");
            let mondainame = getParam("name");
            if (mondaiuserid != null && mondainame != null) {
                isCustom = true;
                mondai = mondainame;
            } else {
                mondai = "hard"; //デフォルトの問題
            }
        }

        const questions = []; // Initialize questions array
        // 設定を一元管理するオブジェクト
        // グローバル設定（問題セット共通）
        const globalSettings = {
            replaceMondai: false, // 問題文と回答文を入れ替えるか
            hardMode: false, // ハードモード
            answerMode: 'choice', // 回答モード（'choice', 'input', 'handwriting', 'word-arrange', 'true-false'）
            pronunciation: false // 発音機能（英単語正解時に発音を再生するか）
        };

        // 問題セット固有の設定
        const problemSettings = {
            questionMode: 'sequential', // 出題モード（'random'または'sequential'）
            currentQuestionIndex: 0 // 順番モードでの現在の問題インデックス
        };

        let answeredQuestions = new Set();
        let maxStreak = 0;
        let performanceHistory = [];
        let performanceChart = null;
        let questionStats = new Map();
        let answerTimes = [];
        let studyingQuestions = new Set();

        let isInReviewMode = false;
        let reviewQuestions = [];
        let reviewStreaks = {}; // { questionIndex: streakCount }


        function pageback() {
            const referrer = document.referrer;
            const currentHost = location.hostname;
            if (referrer) {
                try {
                    const referrerHost = new URL(referrer).hostname;
                    if (referrerHost === currentHost) {
                        history.back();
                    } else {
                        location.href = '../';
                    }
                } catch (e) {
                    location.href = '../';
                }
            } else {
                location.href = '../';
            }
        }

        // 音声再生用の関数
        function playWord(word) {
            const audioPlayer = document.getElementById('audioPlayer');
            audioPlayer.src = `/api/gen/speak/${encodeURIComponent(word)}`;
            audioPlayer.play().catch(() => { });
        }

        // 発音機能：英単語の正解時に発音を再生する関数
        function playCorrectAnswerPronunciation(answer) {
            // 発音機能が有効で、英単語問題セットの場合のみ実行
            if (!globalSettings.pronunciation || !isProblemSetEnglish()) {
                return;
            }
            
            // 回答が英単語かどうかを確認
            if (isEnglishWord(answer)) {
                // 少し遅延してから発音を再生（正解通知の後に再生されるように）
                setTimeout(() => {
                    playWord(answer);
                }, 800);
            }
        }

        function loadQuestions() {
            const showErrorMessage = (errorMessage) => {
                notie.force({
                    type: 'error',
                    text: errorMessage,
                    buttonText: '閉じる',
                    callback: function () {
                        // エラーメッセージ表示後に実行する処理（例：トップページへのリダイレクト）
                        window.location.href = "../";
                    }
                });
                // タイトル領域にもエラーメッセージを表示
                // XSS対策として、errorMessageをエスケープしてから挿入
                const escapeHtml = (unsafe) => {
                    return unsafe
                        .replace(/&/g, "&amp;")
                        .replace(/</g, "&lt;")
                        .replace(/>/g, "&gt;")
                        .replace(/"/g, "&quot;")
                        .replace(/'/g, "&#039;");
                };

                document.getElementById('question').innerHTML =
                    `
                    <div class="error-message">
                        <i class="fas fa-exclamation-triangle"></i>
                        <p>${escapeHtml(errorMessage)}</p>
                        <button onclick="window.location.href='../'">トップページへ戻る</button>
                    </div>
                `;
            };

            const checkResponse = (response, source) => {
                if (!response.ok) {
                    if (response.status === 404) {
                        const errorMsg = `問題ファイルが見つかりませんでした（${source}: ${mondai}）`;
                        showErrorMessage(errorMsg);
                        throw new Error(errorMsg);
                    } else {
                        const errorMsg = `問題の読み込みに失敗しました（ステータス: ${response.status}）`;
                        showErrorMessage(errorMsg);
                        throw new Error(errorMsg);
                    }
                }
                return response;
            };

            if (isCustom) {
                return fetch("/api/get/mondai/" + accid + "/" + mondai + '.json')
                    .then(response => checkResponse(response, 'カスタム問題'))
                    .then(response => response.json())
                    .then(data => {
                        data.forEach(item => {
                            if (item.mondai == undefined) {
                                questions.push({
                                    word: item.word,
                                    description: item.description,
                                });
                            } else {
                                // mondaiフィールドが文字列の場合はパースを試みる
                                let mondaiData = item.mondai;
                                if (typeof mondaiData === 'string') {
                                    try {
                                        mondaiData = JSON.parse(mondaiData);
                                    } catch (e) {
                                        mondaiData = [];
                                    }
                                } else if (!Array.isArray(mondaiData)) {
                                    mondaiData = [];
                                }

                                questions.push({
                                    word: item.word,
                                    description: item.description,
                                    mondai: mondaiData
                                });
                            }
                        });
                    })
                    .catch(error => {

                    });
            } else {
                // URLから開始と終了の問題番号を取得
                const startNum = parseInt(getParam("start")) || 1;
                const endNum = parseInt(getParam("end")) || null;
                // APIから範囲指定で問題を取得
                const apiUrl =
                    `/api/get/mondai/${mondai}.json?start=${startNum - 1}${endNum && endNum >= startNum ? `&end=${endNum}` : ''}`;
                return fetch(apiUrl)
                    .then(response => checkResponse(response, '範囲指定問題API'))
                    .then(response => response.json())
                    .then(data => {
                        data.forEach(item => {
                            const [word, description, mondaiData] = item.split('|');
                            if (mondaiData === undefined) {
                                questions.push({
                                    word, description
                                });
                            } else {
                                questions.push({
                                    word, description, mondai: JSON.parse(mondaiData)
                                });
                            }
                        });
                    })
                    .catch(error => {

                    });
            }
        }

        loadQuestions().then(async () => {
            document.getElementById('total-questions').textContent = questions.length;

            // 設定を読み込む
            loadSettings();

            // 英単語かどうかを判断して要素を制御
            checkAndControlEnglishOnlyFeatures();

            // 問題の選択方法をモードに応じて設定
            selectQuestionMode();

            // もしログインしていれば、サーバーから学習進捗データを読み込む
            if (accid && password) {
                await loadProgressFromServer();
            }

            // 最初の問題表示と進捗更新
            await showNextQuestion();
            updateProgressDisplay(); // 進捗表示を更新
            initializeChart();
            await populateWordList();

            // --- タイマー制御: 初期ロード時に問題画面ならタイマー開始 ---
            if (swiper.activeIndex === 1) {
                start = performance.now();
            }
            // --- タイマー制御ここまで ---

            // 回答モードの設定を再確認（問題データ読み込み完了後）
            validateAnswerModeSettings();

            // 検索インデックスを事前構築（バックグラウンドで実行）
            setTimeout(() => {
                buildSearchIndex();

            }, 1000);
        });

        // 英単語かどうかを判断する関数
        function isEnglishWord(text) {
            if (!text || typeof text !== 'string') return false;
            // 英語の文字、数字、基本的な句読点のみを含む場合に英単語と判断
            // 日本語文字（ひらがな、カタカナ、漢字）が含まれていない場合に英語と判定
            return /^[a-zA-Z0-9\s.,'\-!?;:()]+$/.test(text.trim()) &&
                   !/[\u3040-\u309F\u30A0-\u30FF\u4E00-\u9FAF]/.test(text);
        }

        // 問題セットが英単語かどうかを判断する関数
        function isProblemSetEnglish() {
            if (!questions || questions.length === 0) {
                return false;
            }
            
            // 最初の10問（または全問題数が10未満の場合は全問題）をサンプルとして判断
            const sampleSize = Math.min(10, questions.length);
            let englishCount = 0;
            
            for (let i = 0; i < sampleSize; i++) {
                const question = questions[i];
                if (question && question.word) {
                    const isEnglish = isEnglishWord(question.word);
                    if (isEnglish) {
                        englishCount++;
                    }
                }
            }
            
            const ratio = englishCount / sampleSize;
            const isEnglishSet = ratio >= 0.5; // 判定基準を80%から50%に緩和
            
            return isEnglishSet;
        }

        // 英単語以外の場合に特定の要素を非表示にする関数
        function checkAndControlEnglishOnlyFeatures() {
            const isEnglish = isProblemSetEnglish();
            
            if (!isEnglish) {
                
                // 非表示にする要素を取得（英単語専用機能のみ）
                const replaceMondaiOption = document.querySelector('label[for="replace-mondai"]');
                const hardmodeOption = document.querySelector('label[for="hardmode"]');
                const wordArrangeOption = document.querySelector('label[for="word-arrange-mode"]');
                const pronunciationOption = document.querySelector('label[for="pronunciation"]');
                
                // 要素を非表示にする（親のsettings-optionクラスを持つdivを非表示にする）
                if (replaceMondaiOption) {
                    replaceMondaiOption.parentElement.style.display = 'none';
                }
                if (hardmodeOption) {
                    hardmodeOption.parentElement.style.display = 'none';
                }
                if (wordArrangeOption) {
                    wordArrangeOption.parentElement.style.display = 'none';
                }
                if (pronunciationOption) {
                    pronunciationOption.parentElement.style.display = 'none';
                }
                
                // 発音機能セクション全体を非表示にする
                const pronunciationHeaders = document.querySelectorAll('h3');
                pronunciationHeaders.forEach(header => {
                    if (header.textContent.includes('発音機能')) {
                        header.style.display = 'none';
                    }
                });
                
                // リスニングモードセクション全体を非表示にする
                const listeningHeaders = document.querySelectorAll('h3');
                listeningHeaders.forEach(header => {
                    if (header.textContent.includes('リスニングモード')) {
                        header.style.display = 'none';
                        // 次の要素（リンク）も非表示にする
                        if (header.nextElementSibling) {
                            header.nextElementSibling.style.display = 'none';
                        }
                    }
                });
                
                // 英単語並び替えモードが選択されている場合は4択モードに変更
                if (globalSettings.answerMode === 'word-arrange') {
                    globalSettings.answerMode = 'choice';
                    document.getElementById('choice-mode').checked = true;
                    saveSettings();
                    
                    // ユーザーに通知
                    setTimeout(() => {
                        notie.alert({
                            type: 'warning',
                            text: '英単語並び替えモードは英単語問題でのみ利用可能です。4択モードに変更しました。',
                            time: 3
                        });
                    }, 1000);
                }
                
                // ハードモードが有効になっている場合は無効にする
                if (globalSettings.hardMode) {
                    globalSettings.hardMode = false;
                    document.getElementById('hardmode').checked = false;
                    saveSettings();
                }
            } else {
            }
        }

        // 回答モード設定の妥当性を検証する関数（問題データ読み込み完了後に呼ばれる）
        function validateAnswerModeSettings() {
            // 回答モード設定の妥当性を検証する関数（問題データ読み込み完了後に呼ばれる）
            
            // 英単語並び替えモードが選択されているかチェック
            if (globalSettings.answerMode === 'word-arrange') {
                const isEnglishSet = isProblemSetEnglish();
                
                if (!isEnglishSet) {
                    globalSettings.answerMode = 'choice';
                    document.getElementById('choice-mode').checked = true;
                    saveSettings();
                    
                    // ユーザーに通知
                    setTimeout(() => {
                        notie.alert({
                            type: 'warning',
                            text: '英単語並び替えモードは英単語問題でのみ利用可能です。4択モードに変更しました。',
                            time: 3
                        });
                    }, 500);
                } else {
                }
            }
            
            // 初期状態でもUIをセットアップ（問題表示前に呼ばれるため、correctAnswerはnullでOK）
            if (swiper.activeIndex === 1) {
                setupAnswerModeUI(null);
            }
        }

        async function populateWordList() {
            let listHTML = ''; // HTML文字列を構築
            const englishWords = []; // 英単語を格納する配列
            
            // 英単語を抽出
            questions.forEach(question => {
                const isEnglishWord = /^[a-zA-Z0-9\s.,'\-]+$/.test(question.word.trim()) &&
                                    !/[\u3040-\u309F\u30A0-\u30FF\u4E00-\u9FAF]/.test(question.word);
                if (isEnglishWord) {
                    englishWords.push(question.word);
                }
            });

            // 英単語の辞書情報を一括取得
            let dictResults = {};
            if (englishWords.length > 0) {
                try {
                    const response = await fetch('/api/dict/search', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            word: '',
                            batch_words: englishWords
                        })
                    });
                    
                    if (response.ok) {
                        const data = await response.json();
                        if (data.success && data.results) {
                            dictResults = data.results;
                        }
                    }
                } catch (error) {
                    console.error('辞書検索エラー:', error);
                }
            }

            questions.forEach(question => {
                let titleHTML, contentHTML;
                const titleClass = 'tangotitle';
                const contentClass = 'content no-swiping';

                titleHTML = question.word;
                contentHTML = question.description;

                const isEnglishWord = /^[a-zA-Z0-9\s.,'\-]+$/.test(titleHTML.trim()) &&
                                    !/[\u3040-\u309F\u30A0-\u30FF\u4E00-\u9FAF]/.test(titleHTML);
                const speakerIcon = isEnglishWord ?
                    `  <i class="fas fa-volume-up speak-icon" onclick="playWord('${titleHTML}')"></i>` :
                    '';

                // 英単語の場合、辞書情報を追加
                let wordInfo = titleHTML;
                let additionalInfo = '';
                
                if (isEnglishWord && dictResults[titleHTML]) {
                    const dictInfo = dictResults[titleHTML];
                    if (dictInfo.found) {
                        // 品詞を表示
                        if (dictInfo.pos) {
                            wordInfo += ` <span class="pos-tag">${dictInfo.pos}</span>`;
                        }
                        
                        additionalInfo = '<div class="word-details">';
                        
                        // 過去形・過去分詞を表示（動詞の場合）
                        if (dictInfo.past_tense && dictInfo.past_participle) {
                            if (dictInfo.past_tense === dictInfo.past_participle) {
                                additionalInfo += `<div class="past-forms">${dictInfo.past_tense}</div>`;
                            } else {
                                additionalInfo += `<div class="past-forms">${dictInfo.past_tense} / ${dictInfo.past_participle}</div>`;
                            }
                        }
                        
                        // 他の意味を表示
                        if (dictInfo.meanings && dictInfo.meanings.length > 0) {
                            const otherMeanings = dictInfo.meanings.filter(meaning => meaning !== contentHTML);
                            if (otherMeanings.length > 0) {
                                additionalInfo += `<div class="other-meanings">${otherMeanings.join(', ')}</div>`;
                            }
                        }
                        
                        additionalInfo += '</div>';
                    }
                }

                if (contentHTML.endsWith("か。") || contentHTML.endsWith("答えよ。") ||
                    contentHTML.endsWith("答えなさい。")) {
                    listHTML +=
                        `<li><div class="${contentClass}">${contentHTML}${speakerIcon}</div><div class="${titleClass}">${wordInfo}</div>${additionalInfo}</li>`;
                } else {
                    listHTML +=
                        `<li><div class="${titleClass}">${wordInfo}${speakerIcon}</div><div class="${contentClass}">${contentHTML}</div>${additionalInfo}</li>`;
                }
            });

            document.getElementById('wordList').innerHTML = listHTML;
        }

        let currentIndex;
        let totalCount = 0;
        let correctCount = 0;
        let wrongCount = 0;
        let renzokuseikai = 0;

        async function showNextQuestion() {
            if (currentIndex === undefined || currentIndex < 0 || currentIndex >=
                questions.length) {

                if (questions.length > 0) {
                    currentIndex = 0;
                } else {
                    document.getElementById('question').innerHTML = "問題がありません。";
                    return;
                }
            }
            const question = questions[currentIndex];
            if (!question) {

                return;
            }

            const title = document.getElementById('question');
            const isReversed = globalSettings.replaceMondai;
            const isHardMode = globalSettings.hardMode;
            const screenWidth = window.innerWidth;
            const screenHeight = window.innerHeight;

            // 問題文表示
            if (!isHardMode) {
                let textContent;
                if (isReversed) {
                    title.innerHTML = question.word;
                    textContent = question.word;
                } else {
                    title.innerHTML = question.description;
                    textContent = question.description;
                }

                const textLength = textContent.length;
                if (screenWidth < 600 || screenHeight < 600) {
                    if (textLength >= 150) title.style.fontSize = "0.8em";
                    else if (textLength >= 100) title.style.fontSize = "1em";
                    else title.style.fontSize = "1.3em";
                } else if (screenWidth < 1200 || screenHeight < 800) {
                    if (textLength >= 150) title.style.fontSize = "1em";
                    else if (textLength >= 100) title.style.fontSize = "1.2em";
                    else title.style.fontSize = "1.4em";
                } else {
                    if (textLength >= 150) title.style.fontSize = "1.2em";
                    else if (textLength >= 100) title.style.fontSize = "1.3em";
                    else title.style.fontSize = "1.4em";
                }
            }
            let correctAnswer = isReversed ? question.description : question.word;
            let options = [correctAnswer]; // 正解は必ず含める
            let incorrectOptions = [];
            let otherOptions = []; // すべてのケースで使用できるように変数を定義

            // 1. 不正解選択肢の候補を集める
            if (isReversed) {
                // 反転モード: 他の問題の説明文を候補に
                questions.forEach((q, index) => {
                    if (index !== currentIndex && q.description !== correctAnswer && !
                        incorrectOptions.includes(q.description)) {
                        incorrectOptions.push(q.description);
                    }
                });
            } else {
                // 通常モード
                if (question.mondai) {
                    // mondaiフィールドあり: 指定の不正解選択肢を優先使用
                    const providedIncorrect = Array.isArray(question.mondai) ? question.mondai : [];

                    // mondaiの選択肢を優先的に使用（正解との重複を除外）
                    providedIncorrect.forEach(opt => {
                        if (opt !== correctAnswer && !incorrectOptions.includes(opt)) {
                            incorrectOptions.push(opt);
                        }
                    });
                }

                // 他の問題の単語も候補に追加 (mondaiの選択肢と区別するため別の配列に)
                questions.forEach((q, index) => {
                    if (index !== currentIndex && q.word !== correctAnswer && !
                        incorrectOptions.includes(q.word)) {
                        otherOptions.push(q.word);
                    }
                });
            }

            // 2. ハードモード処理 (文章問題の生成)
            if (isHardMode && !isReversed) {
                // ハードモード時は /api/get/sentences から文章を取得して問題にする
                try {
                    const response = await fetch('/api/get/sentences', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            words: [correctAnswer]
                        }) // 正解の単語を送信
                    });
                    if (!response.ok) {
                        throw new Error(`API request failed with status ${response.status}`);
                    }
                    const sentenceData = await response.json();
                    if (sentenceData.results && sentenceData.results[correctAnswer] &&
                        sentenceData.results[correctAnswer].length > 0) {
                        const sentences = sentenceData.results[correctAnswer];
                        const sentenceForQuestion = sentences[Math.floor(Math.random() * sentences
                            .length)]; // ランダムに1文選択

                        // 正規表現のエスケープ関数
                        function escapeRegExp(string) {
                            return string.replace(/[.*+?^${}()|[]\]/g, '\\$&');
                        }

                        // 文章を日本語と英語に分割
                        const parts = sentenceForQuestion.split('|');
                        let processedSentence = sentenceForQuestion;
                        
                        if (parts.length >= 2) {
                            const japanesePart = parts[0];
                            const englishPart = parts[1];
                            
                            // 辞書検索APIで英単語の意味を取得してアンダーラインを追加
                            try {
                                const dictResponse = await fetch('/api/dict/search', {
                                    method: 'POST',
                                    headers: {
                                        'Content-Type': 'application/json'
                                    },
                                    body: JSON.stringify({
                                        word: correctAnswer
                                    })
                                });
                                
                                if (dictResponse.ok) {
                                    const dictData = await dictResponse.json();
                                    if (dictData.success && dictData.found && dictData.meanings && dictData.meanings.length > 0) {
                                        let modifiedJapanesePart = japanesePart;
                                        
                                        // 各意味に対してアンダーラインを適用（語幹マッチング対応）
                                        dictData.meanings.forEach(meaning => {
                                            if (meaning && meaning.trim()) {
                                                const cleanMeaning = meaning.trim();
                                                
                                                // 1. 完全一致をチェック
                                                const exactRegex = new RegExp(escapeRegExp(cleanMeaning), 'g');
                                                modifiedJapanesePart = modifiedJapanesePart.replace(exactRegex, `<u style="text-decoration-color: #007bff; text-decoration-thickness: 2px;">${cleanMeaning}</u>`);
                                                
                                                // 2. 語幹ベースのマッチング（動詞・形容詞の活用形に対応）
                                                if (cleanMeaning.length >= 3) {
                                                    let stem = '';
                                                    
                                                    // 動詞の語幹抽出
                                                    if (cleanMeaning.endsWith('む')) {
                                                        stem = cleanMeaning.slice(0, -1); // 楽しむ → 楽し
                                                    } else if (cleanMeaning.endsWith('る')) {
                                                        stem = cleanMeaning.slice(0, -1); // 見る → 見
                                                    } else if (cleanMeaning.endsWith('す')) {
                                                        stem = cleanMeaning.slice(0, -1); // 話す → 話
                                                    } else if (cleanMeaning.endsWith('く')) {
                                                        stem = cleanMeaning.slice(0, -1); // 歩く → 歩
                                                    } else if (cleanMeaning.endsWith('ぐ')) {
                                                        stem = cleanMeaning.slice(0, -1); // 泳ぐ → 泳
                                                    } else if (cleanMeaning.endsWith('つ')) {
                                                        stem = cleanMeaning.slice(0, -1); // 待つ → 待
                                                    } else if (cleanMeaning.endsWith('ぬ')) {
                                                        stem = cleanMeaning.slice(0, -1); // 死ぬ → 死
                                                    } else if (cleanMeaning.endsWith('ぶ')) {
                                                        stem = cleanMeaning.slice(0, -1); // 遊ぶ → 遊
                                                    } else if (cleanMeaning.endsWith('う')) {
                                                        stem = cleanMeaning.slice(0, -1); // 買う → 買
                                                    } else if (cleanMeaning.endsWith('い')) {
                                                        stem = cleanMeaning.slice(0, -1); // 楽しい → 楽し
                                                    }
                                                    
                                                    // 語幹が抽出できた場合、関連する表現をマッチング
                                                    if (stem.length >= 2) {
                                                        // よくある活用パターンを直接指定
                                                        let commonPatterns = [
                                                            stem + 'める', // 楽しめる
                                                            stem + 'んだ',  // 楽しんだ
                                                            stem + 'んで',  // 楽しんで
                                                            stem + 'みます', // 楽しみます
                                                            stem + 'まない', // 楽しまない
                                                            stem + 'ませんでした', // 楽しませんでした
                                                            stem + 'もう',   // 楽しもう
                                                            stem + 'そう',   // 楽しそう
                                                            stem + 'く',     // 楽しく
                                                            stem + 'かった', // 楽しかった
                                                            stem + 'くない', // 楽しくない
                                                            stem + 'さ',     // 楽しさ
                                                            stem + 'み',     // 楽しみ
                                                        ];
                                                        
                                                        // 特殊な音変化パターンを追加
                                                        if (cleanMeaning.endsWith('つ')) {
                                                            // つ動詞の音変化: 待つ → 待ち、待って
                                                            commonPatterns.push(
                                                                stem + 'ち',     // 待ち
                                                                stem + 'ちます',  // 待ちます
                                                                stem + 'ちません', // 待ちません
                                                                stem + 'ちたい',  // 待ちたい
                                                                stem + 'ちきれない', // 待ちきれない
                                                                stem + 'ちわびる', // 待ちわびる
                                                                stem + 'って',    // 待って
                                                                stem + 'った',    // 待った
                                                            );
                                                        } else if (cleanMeaning.endsWith('く')) {
                                                            // く動詞の音変化: 歩く → 歩き、歩いて
                                                            commonPatterns.push(
                                                                stem + 'き',     // 歩き
                                                                stem + 'きます',  // 歩きます
                                                                stem + 'きません', // 歩きません
                                                                stem + 'きたい',  // 歩きたい
                                                                stem + 'いて',    // 歩いて
                                                                stem + 'いた',    // 歩いた
                                                            );
                                                        } else if (cleanMeaning.endsWith('ぐ')) {
                                                            // ぐ動詞の音変化: 泳ぐ → 泳ぎ、泳いで
                                                            commonPatterns.push(
                                                                stem + 'ぎ',     // 泳ぎ
                                                                stem + 'ぎます',  // 泳ぎます
                                                                stem + 'ぎません', // 泳ぎません
                                                                stem + 'ぎたい',  // 泳ぎたい
                                                                stem + 'いで',    // 泳いで
                                                                stem + 'いだ',    // 泳いだ
                                                            );
                                                        } else if (cleanMeaning.endsWith('ぶ')) {
                                                            // ぶ動詞の音変化: 遊ぶ → 遊び、遊んで
                                                            commonPatterns.push(
                                                                stem + 'び',     // 遊び
                                                                stem + 'びます',  // 遊びます
                                                                stem + 'びません', // 遊びません
                                                                stem + 'びたい',  // 遊びたい
                                                                stem + 'んで',    // 遊んで
                                                                stem + 'んだ',    // 遊んだ
                                                            );
                                                        } else if (cleanMeaning.endsWith('む')) {
                                                            // む動詞の音変化: 読む → 読み、読んで
                                                            commonPatterns.push(
                                                                stem + 'み',     // 読み
                                                                stem + 'みます',  // 読みます
                                                                stem + 'みません', // 読みません
                                                                stem + 'みたい',  // 読みたい
                                                                stem + 'んで',    // 読んで
                                                                stem + 'んだ',    // 読んだ
                                                            );
                                                        } else if (cleanMeaning.endsWith('ぬ')) {
                                                            // ぬ動詞の音変化: 死ぬ → 死に、死んで
                                                            commonPatterns.push(
                                                                stem + 'に',     // 死に
                                                                stem + 'にます',  // 死にます
                                                                stem + 'にません', // 死にません
                                                                stem + 'にたい',  // 死にたい
                                                                stem + 'んで',    // 死んで
                                                                stem + 'んだ',    // 死んだ
                                                            );
                                                        } else if (cleanMeaning.endsWith('す')) {
                                                            // す動詞の音変化: 話す → 話し、話して
                                                            commonPatterns.push(
                                                                stem + 'し',     // 話し
                                                                stem + 'します',  // 話します
                                                                stem + 'しません', // 話しません
                                                                stem + 'したい',  // 話したい
                                                                stem + 'して',    // 話して
                                                                stem + 'した',    // 話した
                                                            );
                                                        }
                                                        
                                                        commonPatterns.forEach(pattern => {
                                                            try {
                                                                const patternRegex = new RegExp(escapeRegExp(pattern), 'g');
                                                                modifiedJapanesePart = modifiedJapanesePart.replace(patternRegex, (match) => {
                                                                    // 既にアンダーラインが引かれていないかチェック
                                                                    if (!modifiedJapanesePart.includes(`<u style="text-decoration-color: #007bff; text-decoration-thickness: 2px;">${match}</u>`)) {
                                                                        return `<u style="text-decoration-color: #007bff; text-decoration-thickness: 2px;">${match}</u>`;
                                                                    }
                                                                    return match;
                                                                });
                                                            } catch (regexError) {
                                                                // 正規表現エラーは無視
                                                            }
                                                        });
                                                    }
                                                }
                                            }
                                        });
                                        
                                        processedSentence = modifiedJapanesePart + '|' + englishPart;
                                    }
                                }
                            } catch (dictError) {
                                console.log('辞書検索エラー:', dictError);
                                // エラーが発生しても処理を続行
                            }
                        }

                        // 問題文を書き換え
                        // グローバルな正規表現を使用して、すべての | を <br> に置換
                        title.innerHTML = processedSentence.replace(/\|/g, "<br>").replace(new RegExp(
                            escapeRegExp(correctAnswer), "g"), "(     )");
                        // フォントサイズ調整 (新しい問題文の長さに合わせて)
                        textlength = sentenceForQuestion.length;
                        if (screenWidth < 600 || screenHeight < 600) {
                            if (textlength >= 150) title.style.fontSize = "0.8em";
                            else if (textlength >= 100) title.style.fontSize = "1em";
                            else title.style.fontSize = "1.3em";
                        } else if (screenWidth < 1200 || screenHeight < 800) {
                            if (textlength >= 150) title.style.fontSize = "1em";
                            else if (textlength >= 100) title.style.fontSize = "1.2em";
                            else title.style.fontSize = "1.4em";
                        } else {
                            if (textlength >= 150) title.style.fontSize = "1.2em";
                            else if (textlength >= 100) title.style.fontSize = "1.3em";
                            else title.style.fontSize = "1.4em";
                        }

                        // 選択肢は元の単語が正解、他はダミーまたは他の単語
                        options = [correctAnswer]; // 正解は元の単語
                        incorrectOptions = []; // 不正解選択肢を初期化

                        // 他の問題の単語を不正解の候補として集める
                        questions.forEach((q, index) => {
                            if (index !== currentIndex && q.word !== correctAnswer && !
                                incorrectOptions.includes(q.word)) {
                                incorrectOptions.push(q.word);
                            }
                        });

                    }
                } catch (error) {
                    // エラーが発生した場合は通常の選択肢生成に戻る
                    incorrectOptions = [];
                    questions.forEach((q, index) => {
                        if (index !== currentIndex && q.word !== correctAnswer && !
                            incorrectOptions.includes(q.word)) {
                            incorrectOptions.push(q.word);
                        }
                    });
                }
            }


            // 3. 最終的な選択肢リストを作成 (不正解選択肢を追加)
            // まず、mondaiで指定された選択肢を優先的に追加
            incorrectOptions.sort(() => Math.random() - 0.5); // 不正解候補をシャッフル
            while (options.length < 4 && incorrectOptions.length > 0) {
                const incorrectOption = incorrectOptions.shift();
                if (!options.includes(incorrectOption)) { // 重複チェック
                    options.push(incorrectOption);
                }
            }

            // mondaiの選択肢だけでは足りない場合、他の問題から選択肢を追加
            if (options.length < 4 && otherOptions.length > 0) {
                otherOptions.sort(() => Math.random() - 0.5); // 他の候補もシャッフル
                while (options.length < 4 && otherOptions.length > 0) {
                    const otherOption = otherOptions.shift();
                    if (!options.includes(otherOption)) { // 重複チェック
                        options.push(otherOption);
                    }
                }
            }

            // 4. ダミー選択肢ではなく、他の問題からもっと広く選択肢を選ぶ
            if (options.length < 4) {
                // すべての問題から選択肢候補を収集（現在未使用のもの）
                const allPossibleOptions = [];
                questions.forEach((q, idx) => {
                    // 現在の問題と選択肢に既に入っているものを除外
                    if (idx !== currentIndex) {
                        // isReversedに応じて、適切なフィールドを選択肢として使用
                        const optionText = isReversed ? q.description : q.word;
                        if (!options.includes(optionText)) {
                            allPossibleOptions.push(optionText);
                        }
                    }
                });

                // シャッフルして使う
                allPossibleOptions.sort(() => Math.random() - 0.5);

                while (options.length < 4 && allPossibleOptions.length > 0) {
                    options.push(allPossibleOptions.shift());
                }

                // それでも足りない場合（問題数が少ない場合など）は末尾に番号付き選択肢を追加
                let backupCount = 1;
                while (options.length < 4) {
                    const backupOption = `選択肢${backupCount++}`;
                    if (!options.includes(backupOption)) {
                        options.push(backupOption);
                    }
                }
            }

            // 5. 選択肢をシャッフルして表示（4択モードの場合のみ）
            if (globalSettings.answerMode === 'choice') {
                options.sort(() => Math.random() - 0.5);
                options.forEach((answer, index) => {
                    document.getElementById('answer' + (index + 1)).textContent = answer;
                });
            }
            // --- 選択肢生成ここまで ---

            // 各モードに応じてUIをセットアップ
            setupAnswerModeUI(correctAnswer);


            // --- タイマー制御: ここでのタイマー開始を削除 ---
            // start = performance.now();
            // --- タイマー制御ここまで ---

            document.getElementById('exit-review-btn').style.display = isInReviewMode ?
                'block' : 'none';
            if (isInReviewMode) {
                document.getElementById('review-count').textContent = reviewQuestions.length;
            }
        }

        function calculateAccuracy() {
            return totalCount === 0 ? 0 : (correctCount / totalCount) * 100;
        }

        function calculateAverageTime() {
            if (answerTimes.length === 0) return 0;
            const sum = answerTimes.reduce((a, b) => a + b, 0);
            return (sum / answerTimes.length / 1000).toFixed(1);
        }

        function initializeChart() {
            const ctx = document.getElementById('performance-chart').getContext('2d');
            performanceChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [{
                        label: '正解率推移',
                        data: [],
                        borderColor: '#007bff',
                        tension: 0.1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            beginAtZero: true,
                            max: 100
                        }
                    }
                }
            });
        }

        function updateChart() {
            if (performanceChart && totalCount > 0) {
                const accuracy = calculateAccuracy();
                performanceHistory.push(accuracy);

                performanceChart.data.labels = Array.from({
                    length: performanceHistory.length
                }, (_, i) => i + 1);
                performanceChart.data.datasets[0].data = performanceHistory;
                performanceChart.update();
            }
        }

        function updateStudyList() {
            const studyList = document.getElementById('study-list');
            studyList.innerHTML = '';

            // studyingQuestions に含まれるインデックスの問題のみ表示
            for (let index of studyingQuestions) {
                if (!questionStats.has(index)) continue; // 統計情報がない場合はスキップ

                const stats = questionStats.get(index);
                const question = questions[index];
                const li = document.createElement('li');
                // 'wrong'クラスは不正解の場合、'long-time'は時間がかかった場合（判定ロジックは必要なら追加）
                li.className =
                    `study-item ${stats.isWrong ? 'wrong-answer' : ''} ${stats.isLongTime ? 'long-time' : ''}`;

                let statusText = [];
                if (stats.isWrong) statusText.push('間違えた問題');
                if (stats.isLongTime) statusText.push('時間がかかった問題');

                li.innerHTML =
                    `
                    <strong>${question.word}</strong><br>
                    <small>${statusText.join(' / ')}</small>
                `;
                studyList.appendChild(li);
            }
            // 復習ボタンの表示/非表示
            document.getElementById('start-review-btn').style.display = studyingQuestions
                .size > 0 ? 'block' : 'none';
        }


        function updateStats() {
            document.getElementById('answered-questions').textContent = answeredQuestions
                .size;
            document.getElementById('correct-answers').textContent = correctCount;
            document.getElementById('wrong-answers').textContent = wrongCount;
            const progressPercentage = questions.length > 0 ? (answeredQuestions.size /
                questions.length) * 100 : 0; // Avoid division by zero
            document.getElementById('progress-percentage').textContent =
                progressPercentage.toFixed(1);
            document.getElementById('progress-bar').style.width = progressPercentage +
                '%';

            document.getElementById('avg-accuracy').textContent = calculateAccuracy().toFixed(
                1);
            document.getElementById('max-streak').textContent = maxStreak;
            document.getElementById('current-streak').textContent = renzokuseikai;
            document.getElementById('avg-time').textContent = calculateAverageTime();

            updateChart();
            updateStudyList();
        }

        async function onAnswerClick(e) {
            document.querySelector('.swiper-button-next').style.display = 'none';
            document.querySelector('.swiper-button-prev').style.display = 'none';

            // --- タイマー制御: startが未定義の場合のフォールバック ---
            if (typeof start === 'undefined' || start === null) {

                start = performance.now(); // 念のため現在時刻を開始時刻とする
            }
            // --- タイマー制御ここまで ---

            const endTime = performance.now();
            const timeTaken = endTime - start;
            answerTimes.push(timeTaken);
            start = null; // 次の問題が表示されるまでタイマー開始時刻をリセット

            const avgTime = calculateAverageTime();
            // 時間がかかったかの判定: 平均の1.5倍以上、かつ最低でも5秒以上かかった場合など調整可能
            const isLongTime = timeTaken / 1000 > Math.max(5, avgTime * 1.5);


            if (!questionStats.has(currentIndex)) {
                questionStats.set(currentIndex, {
                    attempts: 0,
                    correctAnswers: 0,
                    averageTime: 0,
                    isLongTime: false,
                    isWrong: false
                });
            }

            const stats = questionStats.get(currentIndex);
            stats.attempts++;
            // 平均解答時間の計算を更新 (より正確に)
            stats.averageTime = ((stats.averageTime || 0) * (stats.attempts - 1) +
                timeTaken) / stats.attempts;
            stats.isLongTime = isLongTime || stats.isLongTime; // 一度でも時間がかかったらフラグを立てる

            answeredQuestions.add(currentIndex);
            totalCount++;

            const isReversed = globalSettings.replaceMondai;
            const correctAnswer = isReversed ? questions[currentIndex].description :
                questions[currentIndex].word;

            if (e.target.textContent === correctAnswer) { // 正解の場合
                stats.isWrong = false; // 正解したので不正解フラグはリセット
                if (isInReviewMode) {
                    // --- 復習モードの正解処理 ---
                    reviewStreaks[currentIndex] = (reviewStreaks[currentIndex] || 0) + 1; // reviewStreaks[currentIndex]が存在しない場合も考慮
                    if (reviewStreaks[currentIndex] >= 2) {
                        const indexToRemove = reviewQuestions.indexOf(currentIndex);
                        if (indexToRemove > -1) {
                            reviewQuestions.splice(indexToRemove, 1);
                        }
                        delete reviewStreaks[currentIndex];
                        studyingQuestions.delete(currentIndex); // 復習完了したら学習中リストからも削除

                        if (reviewQuestions.length === 0) {
                            isInReviewMode = false;
                            document.getElementById('review-mode-indicator').style.display = 'none';
                            document.getElementById('exit-review-btn').style.display = 'none';
                            notie.alert({
                                type: 'success',
                                text: '復習完了！お疲れ様でした。',
                                time: 3
                            });
                            document.getElementById('review-count').textContent = reviewQuestions.length;

                            swiper.slideTo(0); // 学習進捗画面へ
                            updateStats();
                            saveProgressToServer(); // 進捗保存
                            return; // 次の問題表示に進まない
                        }
                    }
                    // 通常の正解処理も実行 (スコア加算など)
                    correctCount++;
                    renzokuseikai++;
                    if (renzokuseikai > maxStreak) {
                        maxStreak = renzokuseikai;
                    }
                    stats.correctAnswers = (stats.correctAnswers || 0) + 1; // correctAnswersが存在しない場合も考慮
                    notie.alert({
                        type: 1,
                        text: '正解',
                        time: 1
                    });
                    
                    // 発音機能：正解の英単語を発音
                    playCorrectAnswerPronunciation(correctAnswer);
                    
                    updateProgressDisplay();
                    document.getElementById('review-count').textContent = reviewQuestions.length;

                    updateStats();
                    nextIndex();
                    await showNextQuestion();
                    sendScore("add_correct", accid, password);
                    saveProgressToServer(); // 進捗保存
                    // --- 復習モードの正解処理 ここまで ---
                } else {
                    // --- 通常モードの正解処理 ---
                    correctCount++;
                    renzokuseikai++;
                    if (renzokuseikai > maxStreak) {
                        maxStreak = renzokuseikai;
                    }
                    stats.correctAnswers = (stats.correctAnswers || 0) + 1; // correctAnswersが存在しない場合も考慮
                    // 正解回数が2回以上、かつ時間がかかっていない場合に学習中から外す
                    if (stats.correctAnswers >= 2 && !stats.isLongTime) {
                        studyingQuestions.delete(currentIndex);
                    } else if (stats.correctAnswers >= 1 && isLongTime) {
                        studyingQuestions.add(currentIndex); // 1回正解でも時間がかかったら学習中に戻す
                    }
                    notie.alert({
                        type: 1,
                        text: '正解',
                        time: 1
                    });
                    
                    // 発音機能：正解の英単語を発音
                    playCorrectAnswerPronunciation(correctAnswer);
                    
                    updateProgressDisplay();
                    updateStats();
                    nextIndex();
                    await showNextQuestion();
                    sendScore("add_correct", accid, password);
                    saveProgressToServer(); // 進捗保存
                    // --- 通常モードの正解処理 ここまで ---
                }
            } else { // 不正解の場合
                stats.isWrong = true; // 不正解フラグを立てる
                studyingQuestions.add(currentIndex); // 不正解なら必ず学習中リストへ
                if (isInReviewMode) {
                    // --- 復習モードの不正解処理 ---
                    reviewStreaks[currentIndex] = 0; // 連続正解リセット
                    // 通常の不正解処理も実行 (スコア加算など)
                    wrongCount++;
                    renzokuseikai = 0;
                    // stats.isWrong = true; // 上で設定済み
                    // studyingQuestions.add(currentIndex); // 上で設定済み
                    let question = questions[currentIndex];
                    let questionText, answerText;
                    const isHardModeCurrent = globalSettings.hardMode;

                    if (isReversed) {
                        questionText = question.word;
                        answerText = question.description;
                    } else {
                        if (isHardModeCurrent) {
                            questionText = document.getElementById('question').innerHTML; // ハードモード時は表示されている問題文
                        } else {
                            questionText = question.description; // 通常モード
                        }
                        answerText = question.word;
                    }
                    notie.force({
                        type: 'error',
                        text: '<div class="popup">問題：' + questionText + '<br><br>正しい回答:' +
                            answerText + "<br>あなたの回答:" + e.target.textContent + '</div>',
                        buttonText: '私は間違えたことを深くお詫び、反省することを誓います。',
                        callback: async function () {
                            updateProgressDisplay();
                            updateStats();
                            nextIndex(); // 復習モードでも次の問題へ
                            await showNextQuestion();
                            sendScore("add_bad", accid, password);
                            saveProgressToServer(); // 進捗保存
                        }
                    });
                } else {
                    wrongCount++;
                    renzokuseikai = 0;
                    // stats.isWrong = true; // 上で設定済み
                    // studyingQuestions.add(currentIndex); // 上で設定済み
                    let question = questions[currentIndex];
                    let questionText, answerText;
                    const isHardModeCurrent = globalSettings.hardMode;

                    if (isReversed) {
                        questionText = question.word;
                        answerText = question.description;
                    } else {
                        if (isHardModeCurrent) {
                            questionText = document.getElementById('question').innerHTML; // ハードモード時は表示されている問題文
                        } else {
                            questionText = question.description; // 通常モード
                        }
                        answerText = question.word;
                    }
                    notie.force({
                        type: 'error',
                        text: '<div class="popup">問題：' + questionText + '<br><br>正しい回答:' +
                            answerText + "<br>あなたの回答:" + e.target.textContent + '</div>',
                        buttonText: '私は間違えたことを深くお詫び、反省することを誓います。',
                        callback: async function () {
                            updateProgressDisplay();
                            updateStats();
                            // 通常モードの不正解時は同じ問題を表示（nextIndexを呼ばない）
                            // nextIndex(); // この行を削除またはコメントアウト
                            await showNextQuestion();
                            sendScore("add_bad", accid, password);
                            saveProgressToServer(); // 進捗保存
                        }
                    });
                }
            }

            // 時間がかかった場合も学習中にする（正解・不正解共通）
            if (isLongTime) {
                studyingQuestions.add(currentIndex);
                // 必要ならstats.isLongTimeフラグを再度確認してセット
                stats.isLongTime = true;
                updateStats(); // 表示更新
            }
        }
        // 設定をlocalStorageから読み込む関数
        function loadSettings() {
            // グローバル設定を読み込む（一括で）
            try {
                const savedGlobalSettings = localStorage.getItem('quizbox_global_settings');
                if (savedGlobalSettings) {
                    const parsedSettings = JSON.parse(savedGlobalSettings);
                    // 有効なプロパティのみをグローバル設定に適用
                    if (parsedSettings.replaceMondai !== undefined) globalSettings.replaceMondai =
                        parsedSettings.replaceMondai;
                    if (parsedSettings.hardMode !== undefined) globalSettings.hardMode =
                        parsedSettings.hardMode;
                    if (parsedSettings.answerMode) globalSettings.answerMode = parsedSettings.answerMode;
                    if (parsedSettings.pronunciation !== undefined) globalSettings.pronunciation =
                        parsedSettings.pronunciation;
                }
            } catch (e) {
                // 個別設定から読み込み（後方互換性）
                globalSettings.replaceMondai = localStorage.getItem('replace_mondai') ===
                    'true';
                globalSettings.hardMode = localStorage.getItem('hard_mode') === 'true';
                globalSettings.answerMode = localStorage.getItem('answer_mode') || 'choice';
                globalSettings.pronunciation = localStorage.getItem('pronunciation') === 'true';
            }

            // 問題セット固有の設定を読み込む
            try {
                // 範囲指定がある場合は、それを含めたキーを生成
                const startParam = getParam("start");
                const endParam = getParam("end");
                let problemSetKey = mondai;

                if (startParam && endParam) {
                    problemSetKey = `${mondai}_${startParam}_${endParam}`;
                }

                const key = `quizbox_problem_settings_${problemSetKey}`;
                const savedProblemSettings = localStorage.getItem(key);
                if (savedProblemSettings) {
                    const parsedSettings = JSON.parse(savedProblemSettings);
                    // 有効なプロパティのみを問題セット設定に適用
                    if (parsedSettings.questionMode) problemSettings.questionMode =
                        parsedSettings.questionMode;
                    if (parsedSettings.currentQuestionIndex !== undefined) {
                        problemSettings.currentQuestionIndex = parsedSettings.currentQuestionIndex;
                    }
                }
            } catch (e) {
                // 個別設定から読み込み（後方互換性）
                problemSettings.questionMode = localStorage.getItem('question_mode_' +
                    mondai) || 'sequential';
                problemSettings.currentQuestionIndex = parseInt(localStorage.getItem(
                    'current_question_index_' + mondai) || '0');
            }

            // UIに設定を反映
            document.getElementById('replace-mondai').checked = globalSettings.replaceMondai;
            document.getElementById('hardmode').checked = globalSettings.hardMode;
            document.getElementById('pronunciation').checked = globalSettings.pronunciation;
            document.getElementById(problemSettings.questionMode + '-mode').checked =
                true;
            document.getElementById(globalSettings.answerMode + '-mode').checked = true;
        }

        // 設定を保存する関数
        function saveSettings() {
            // グローバル設定を一括で保存
            localStorage.setItem('quizbox_global_settings', JSON.stringify(globalSettings));

            // 問題セット固有の設定を一括で保存（範囲指定がある場合はそれも含める）
            const startParam = getParam("start");
            const endParam = getParam("end");
            let problemSetKey = mondai;

            // start/endパラメータが指定されている場合は、それをキーに含める
            if (startParam && endParam) {
                problemSetKey = `${mondai}_${startParam}_${endParam}`;
            }

            const key = `quizbox_problem_settings_${problemSetKey}`;
            localStorage.setItem(key, JSON.stringify(problemSettings));
        }

        function selectQuestionMode() {
            // 問題セット設定から現在のモードを取得
            const savedMode = problemSettings.questionMode;
            document.getElementById(savedMode + '-mode').checked = true; // UIに反映

            if (savedMode === 'sequential') {
                // 保存されている進捗があれば復元、なければ0から開始
                currentIndex = problemSettings.currentQuestionIndex;
                if (currentIndex >= questions.length || currentIndex < 0) {
                    currentIndex = 0; // インデックスが範囲外なら最初から
                    problemSettings.currentQuestionIndex = 0; // 設定も更新
                    saveSettings(); // 保存
                }
            } else {
                // ランダムモード
                if (questions.length > 0) {
                    currentIndex = Math.floor(Math.random() * questions.length);
                } else {
                    currentIndex = undefined; // 問題がない場合
                }
            }
        }

        function nextIndex() {
            if (questions.length === 0) return; // 問題がない場合は何もしない

            if (isInReviewMode) {
                if (reviewQuestions.length === 0) {
                    // 復習完了時の処理 (念のため)
                    isInReviewMode = false;
                    document.getElementById('review-mode-indicator').style.display = 'none';
                    document.getElementById('exit-review-btn').style.display = 'none';
                    notie.alert({
                        type: 'success',
                        text: '復習完了！',
                        time: 2
                    });
                    swiper.slideTo(0);
                    saveProgressToServer(); // 最後に保存
                    return; // 通常のモード選択に進まない
                }
                let lastReviewIndex = currentIndex;
                // reviewQuestionsが空でないことを確認
                if (reviewQuestions.length > 0) {
                    do {
                        currentIndex = reviewQuestions[Math.floor(Math.random() * reviewQuestions.length)];
                    } while (reviewQuestions.length > 1 && currentIndex === lastReviewIndex); // 問題が2つ以上ある場合のみループ
                } else {
                    // 復習対象がなくなったら復習モードを終了
                    isInReviewMode = false;
                    document.getElementById('review-mode-indicator').style.display = 'none';
                    document.getElementById('exit-review-btn').style.display = 'none';
                    notie.alert({
                        type: 'success',
                        text: '復習完了！',
                        time: 2
                    });
                    swiper.slideTo(0);
                    saveProgressToServer(); // 最後に保存
                    return;
                }

                updateProgressDisplay(); // 復習モードでも進捗表示を更新
                return; // 通常のモード選択に進まない
            }

            const isSequential = problemSettings.questionMode === 'sequential';

            let lastIndex = currentIndex;

            if (isSequential) {
                // 順番モードでは次の問題へ
                currentIndex = (currentIndex + 1) % questions.length;
                // 進捗を保存
                problemSettings.currentQuestionIndex = currentIndex;
                saveSettings();

                // 最後の問題に達して0に戻ったらランダムモードに切り替えるか、通知を出す
                if (currentIndex === 0 && lastIndex === questions.length - 1) { // 厳密に一周したかチェック
                    // ランダムモードに自動で切り替える場合
                    // localStorage.setItem('question_mode_' + mondai, 'random');
                    // document.getElementById('random-mode').checked = true;
                    // document.getElementById('sequential-mode').checked = false;
                    notie.alert({
                        type: 'success',
                        text: 'すべての問題を終了しました。引き続き順番に表示します。', // または 'ランダムモードに切り替えます'
                        time: 3
                    });
                    // selectQuestionMode(); // モードが変わった場合、再選択ロジックを呼ぶ
                }
            } else {
                // ランダムモード（現状の動作）
                if (questions.length > 1) { // 問題が2つ以上ある場合のみループ
                    do {
                        currentIndex = Math.floor(Math.random() * questions.length);
                    } while (currentIndex === lastIndex);
                } else {
                    // 問題が1つしかない場合はインデックスは変わらない
                    currentIndex = 0;
                }
            }

            updateProgressDisplay();
        }

        // 進捗表示を更新する関数
        function updateProgressDisplay() {
            const isSequential = problemSettings.questionMode === 'sequential';

            let scoreText =
                `
                回答数: ${totalCount}
                正解数: ${correctCount}
                不正解数: ${wrongCount}
                連続正解数: ${renzokuseikai}
                正答率: ${calculateAccuracy().toFixed(1)}%
            `;

            if (isSequential && questions.length > 0) {
                // 順番モードでは問題番号も表示 (currentIndexが有効な場合のみ)
                if (currentIndex !== undefined && currentIndex >= 0 && currentIndex <
                    questions.length) {
                    scoreText = `問題 ${currentIndex + 1}/${questions.length}<br>` + scoreText;
                }
            }
            // 復習モードの表示
            if (isInReviewMode) {
                scoreText = `復習中 残り ${reviewQuestions.length} 問<br>` + scoreText;
            }


            document.getElementById('score').innerHTML = scoreText;
        }


        function sendScore(endpoint, id, password) {
            if (!id || !password) return; // ID/Passがない場合は送信しない
            const currentURL = location;
            const url = currentURL.protocol + "//" + currentURL.host + "/api/" + endpoint;
            fetch(url, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    "id": id,
                    "password": password,
                })
            }).then(response => {
                if (!response.ok) {
                    // 401 Unauthorized のようなエラーも考慮

                    // throw new Error('Network response was not ok ' + response.statusText);
                    return null; // エラー時は null を返すなど
                }
                return response.json();
            }).then(data => {
                if (data) {

                }
                // saveProgressToServer(); // スコア送信成功時にも保存 (頻繁すぎる可能性あり)
            }).catch((error) => {

            });
        }

        // サーバーに学習進捗データを保存する関数
        async function saveProgressToServer() { // Make async
            const userId = Cookies.get('id');
            const password = Cookies.get('password');
            if (!userId || !password) return; // ID/Passがない場合は保存しない

            // 範囲指定がある場合は、問題セット名に範囲も含める
            let problemSet = mondai || 'default';
            const startParam = getParam("start");
            const endParam = getParam("end");

            if (startParam && endParam) {
                problemSet = `${mondai}_${startParam}_${endParam}`;
            }
            const totalQuestions = questions.length;

            // 1. 詳細データ (details) を作成
            const detailsData = {
                answeredQuestions: Array.from(answeredQuestions), // Convert Set to Array
                questionStats: Object.fromEntries(questionStats), // Convert Map to Object
                maxStreak: maxStreak,
                performanceHistory: performanceHistory,
                answerTimes: answerTimes,
                studyingQuestions: Array.from(studyingQuestions), // Convert Set to Array
            };

            // learned, learning, unlearned の計算ロジックはそのまま
            let learnedCount = 0;
            let learningCount = 0;

            questionStats.forEach((stats, index) => {
                if (answeredQuestions.has(index)) {
                    // 学習済み条件：正解2回以上 AND 時間がかかっていない
                    if (stats.correctAnswers >= 2 && !stats.isLongTime) {
                        learnedCount++;
                    } else { // それ以外（1回正解、不正解、時間がかかった）は学習中
                        learningCount++;
                    }
                }
            });

            // studyingQuestions に含まれているが stats にない（＝まだ解答していない）ものは learningCount に含めるべきか？
            // answeredQuestions に基づいて計算する方が一貫性がある
            studyingQuestions.forEach(index => {
                if (!answeredQuestions.has(index)) {
                    // まだ解答していないが復習リストに入っている場合？ 基本的には解答済みのはず
                    // learningCount++; // 必要ならカウント
                } else if (!questionStats.has(index) || (questionStats.get(index).correctAnswers <
                    2 || questionStats.get(index).isLongTime)) {
                    // 解答済みだが学習済み条件を満たさない場合、learningCountに含まれているはず
                }
            });


            const unlearnedCount = totalQuestions - learnedCount - learningCount;

            const summaryData = {
                learned: learnedCount,
                learning: learningCount,
                unlearned: Math.max(0, unlearnedCount), // 負にならないように
                total: totalQuestions
            };


            try {
                const response = await fetch('/api/save_progress', { // Use relative path
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        id: userId,
                        password: password,
                        problem_set: problemSet,
                        summary: summaryData, // Send summary data
                        details: detailsData // Send details data
                    }),
                });

                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(
                        `HTTP error! status: ${response.status}, message: ${errorText}`);
                }

                const result = await response.json();

            } catch (error) {

                // ユーザーにエラーを通知する（例: notie）
                // notie.alert({ type: 'error', text: '進捗の保存に失敗しました。', time: 2 });
            }
        }


        // サーバーから学習進捗データを取得する関数
        async function loadProgressFromServer() { // Make async
            if (!accid || !password) return;

            const detailsUrl = "/api/get_progress"; // Endpoint for detailed progress
            const summaryUrl = "/api/get"; // Endpoint for summary data (used for dashboard slide)

            try {
                const detailsResponse = await fetch(detailsUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        id: accid,
                        password: password,
                        problem_set: (() => {
                            // 範囲指定がある場合はそれを含める
                            const startParam = getParam("start");
                            const endParam = getParam("end");
                            if (startParam && endParam) {
                                return `${mondai}_${startParam}_${endParam}`;
                            }
                            return mondai;
                        })()
                    })
                });

                if (!detailsResponse.ok) {
                    if (detailsResponse.status === 404) {

                        answeredQuestions = new Set();
                        questionStats = new Map();
                        studyingQuestions = new Set(); // 初期化
                        localStorage.removeItem('current_question_index_' + mondai); // ローカルのインデックスもクリア
                        localStorage.removeItem('question_mode_' + mondai); // ローカルのモードもクリア
                    } else {
                        throw new Error(
                            `Error fetching progress details: ${detailsResponse.statusText}`);
                    }
                } else {
                    const detailsDataResult = await detailsResponse.json();
                    const detailsData = detailsDataResult.progress_details;
                    if (detailsData && Object.keys(detailsData).length > 0) {

                        applyProgressData(detailsData); // Apply the loaded details
                    } else {

                        answeredQuestions = new Set();
                        questionStats = new Map();
                        studyingQuestions = new Set(); // 初期化
                        localStorage.removeItem('current_question_index_' + mondai);
                        localStorage.removeItem('question_mode_' + mondai);
                    }
                }

                // 2. Fetch Summary Data (for dashboard slide total count)
                const summaryResponse = await fetch(summaryUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        id: accid,
                        password: password
                    })
                });

                if (!summaryResponse.ok) {

                } else {
                    const summaryDataResult = await summaryResponse.json();
                    const summary = summaryDataResult.progress_summary || {};
                    const p = summary[mondai] || {
                        learned: 0,
                        learning: 0,
                        unlearned: 0,
                        total: questions.length
                    };
                    // サーバーからの total があればそれを使う、なければ計算値
                    document.getElementById('total-questions').textContent = p.total ||
                        questions.length;
                }

                // 3. Update UI after potentially loading data
                updateStats(); // Recalculates stats based on loaded data
                selectQuestionMode(); // ローカルストレージ/サーバーからのモードとインデックスを反映してcurrentIndexを設定
                updateProgressDisplay(); // Updates score display

            } catch (error) {

                // Consider showing a user-friendly error message
                notie.alert({
                    type: 'error',
                    text: '進捗の読み込みに失敗しました。',
                    time: 2
                });
            }
        }

        // サーバーから取得した学習進捗データを適用する関数
        function applyProgressData(progressData) {

            answeredQuestions = new Set(progressData.answeredQuestions || []);
            maxStreak = progressData.maxStreak || 0;
            performanceHistory = progressData.performanceHistory || [];
            answerTimes = progressData.answerTimes || [];
            studyingQuestions = new Set(progressData.studyingQuestions || []); // studyingQuestionsも復元

            if (progressData.questionStats && typeof progressData.questionStats ===
                'object') {
                // questionStats の各エントリを数値キーの Map に変換
                questionStats = new Map();
                for (const key in progressData.questionStats) {
                    if (Object.hasOwnProperty.call(progressData.questionStats, key)) {
                        // キーを数値に変換、statsオブジェクトをそのまま値としてセット
                        questionStats.set(parseInt(key), progressData.questionStats[key]);
                    }
                }
            } else {
                questionStats = new Map();
            }

            // ユーザー設定の復元
            // 問題セット固有の設定を復元
            if (progressData.questionMode) {
                problemSettings.questionMode = progressData.questionMode;
            }

            if (progressData.currentQuestionIndex !== undefined) {
                // サーバーから取得したインデックスが有効範囲内かチェック
                const savedIndex = progressData.currentQuestionIndex;
                if (savedIndex >= 0 && savedIndex < questions.length) {
                    problemSettings.currentQuestionIndex = savedIndex;
                } else {
                    problemSettings.currentQuestionIndex = 0; // 無効なら0にリセット
                }
            }

            // グローバル設定も復元
            if (progressData.replaceMondai !== undefined) {
                globalSettings.replaceMondai = progressData.replaceMondai;
            }

            if (progressData.hardMode !== undefined) {
                globalSettings.hardMode = progressData.hardMode;
            }

            if (progressData.answerMode) {
                globalSettings.answerMode = progressData.answerMode;
            }

            if (progressData.pronunciation !== undefined) {
                globalSettings.pronunciation = progressData.pronunciation;
            }

            // UIに設定を反映
            document.getElementById(problemSettings.questionMode + '-mode').checked =
                true;
            document.getElementById('replace-mondai').checked = globalSettings.replaceMondai;
            document.getElementById('hardmode').checked = globalSettings.hardMode;
            document.getElementById('pronunciation').checked = globalSettings.pronunciation;
            document.getElementById(globalSettings.answerMode + '-mode').checked = true;
            // ローカルストレージにも保存
            saveSettings();

            // correctCount, wrongCount, totalCount を questionStats から再計算
            correctCount = 0;
            wrongCount = 0;
            totalCount = 0;
            if (questionStats.size > 0) {
                answeredQuestions.forEach(index => {
                    const stats = questionStats.get(index);
                    if (stats) { // statsが存在する場合のみ計算
                        totalCount += stats.attempts || 0;
                        correctCount += stats.correctAnswers || 0;
                        wrongCount += (stats.attempts || 0) - (stats.correctAnswers || 0);
                    }
                });
            } else {
                // questionStatsがない場合（古いデータなど）はansweredQuestionsのサイズをtotalCountとする
                totalCount = answeredQuestions.size;
                // この場合、correct/wrongは0のまま（情報がないため）
            }

            // updateStats(); // この関数を呼び出す loadProgressFromServer の最後で updateStats が呼ばれるので、ここでは不要
        }


        document.getElementById('answer1').addEventListener('click', onAnswerClick);
        document.getElementById('answer2').addEventListener('click', onAnswerClick);
        document.getElementById('answer3').addEventListener('click', onAnswerClick);
        document.getElementById('answer4').addEventListener('click', onAnswerClick);

        // モーダルを初期化
        MicroModal.init({
            awaitOpenAnimation: true,
            awaitCloseAnimation: true
        });
        document.getElementById('settings-btn').addEventListener('click', function () {
            MicroModal.show('settings-modal');
        });

        // --- レーベンシュタイン距離計算関数 ---
        function calculateLevenshteinDistance(a, b) {
            if (a.length === 0) return b.length;
            if (b.length === 0) return a.length;

            const matrix = [];

            // increment along the first column of each row
            for (let i = 0; i <= b.length; i++) {
                matrix[i] = [i];
            }

            // increment each column in the first row
            for (let j = 0; j <= a.length; j++) {
                matrix[0][j] = j;
            }

            // Fill in the rest of the matrix
            for (let i = 1; i <= b.length; i++) {
                for (let j = 1; j <= a.length; j++) {
                    const cost = (b.charAt(i - 1) === a.charAt(j - 1)) ? 0 : 1;
                    matrix[i][j] = Math.min(
                        matrix[i - 1][j] + 1, // deletion
                        matrix[i][j - 1] + 1, // insertion
                        matrix[i - 1][j - 1] + cost // substitution
                    );
                }
            }

            return matrix[b.length][a.length];
        }
        // --- レーベンシュタイン距離計算関数 ここまで ---


        // 問題文と回答文を入れ換える機能
        const replaceMondaiCheckbox = document.getElementById('replace-mondai');

        // チェックボックスの変更イベント
        replaceMondaiCheckbox.addEventListener('change', async function () {
            globalSettings.replaceMondai = this.checked;
            saveSettings();

            // 現在の画面に合わせて更新
            await populateWordList(); // 単語リスト再表示

            if (swiper.activeIndex === 1) {
                // 問題画面表示中なら問題も更新
                await showNextQuestion();
                notie.alert({
                    type: 'info',
                    text: this.checked ? '問題文と回答文を入れ替えました' : '問題文と回答文を元に戻しました',
                    time: 1.5
                });
            }

            swiper.update(); // スワイパー更新
        });

        // ハードモード機能
        const hardmodeCheckbox = document.getElementById('hardmode');

        // ハードモードチェックボックスの変更イベント
        hardmodeCheckbox.addEventListener('change', async function () {
            // 英単語以外の問題セットでハードモードを有効にしようとした場合は無効にする
            if (this.checked && !isProblemSetEnglish()) {
                notie.alert({
                    type: 'warning',
                    text: 'ハードモードは英単語問題でのみ利用可能です。',
                    time: 3
                });
                this.checked = false;
                globalSettings.hardMode = false;
            } else {
                globalSettings.hardMode = this.checked;
            }
            
            saveSettings();

            if (swiper.activeIndex === 1) {
                // 問題画面表示中なら問題も更新
                await showNextQuestion();
                notie.alert({
                    type: 'info',
                    text: this.checked ? 'ハードモードを有効にしました' : 'ハードモードを無効にしました',
                    time: 1.5
                });
            }
        });

        // 発音機能チェックボックスの変更イベント
        const pronunciationCheckbox = document.getElementById('pronunciation');
        pronunciationCheckbox.addEventListener('change', function () {
            // 英単語以外の問題セットで発音機能を有効にしようとした場合は無効にする
            if (this.checked && !isProblemSetEnglish()) {
                notie.alert({
                    type: 'warning',
                    text: '発音機能は英単語問題でのみ利用可能です。',
                    time: 3
                });
                this.checked = false;
                globalSettings.pronunciation = false;
            } else {
                globalSettings.pronunciation = this.checked;
            }
            
            saveSettings();
            
            notie.alert({
                type: 'info',
                text: this.checked ? '発音機能を有効にしました' : '発音機能を無効にしました',
                time: 1.5
            });
        });

        // 出題モード選択のイベントリスナー
        document.getElementById('random-mode').addEventListener('change', async function () {
            if (this.checked) {
                problemSettings.questionMode = 'random';
                saveSettings();
                selectQuestionMode(); // モード選択ロジックを呼び出してcurrentIndexを更新
                await showNextQuestion();
                updateProgressDisplay();
                notie.alert({
                    type: 'info',
                    text: 'ランダム出題モードに切り替えました',
                    time: 1.5
                });
            }
        });

        document.getElementById('sequential-mode').addEventListener('change', async function () {
            if (this.checked) {
                problemSettings.questionMode = 'sequential';
                saveSettings();
                selectQuestionMode(); // モード選択ロジックを呼び出してcurrentIndexを更新
                await showNextQuestion();
                updateProgressDisplay();
                notie.alert({
                    type: 'info',
                    text: '順番出題モードに切り替えました',
                    time: 1.5
                });
            }
        });

        document.querySelectorAll('input[name="answer-mode"]').forEach(radio => {
            radio.addEventListener('change', async function () {
                const choiceArea = document.getElementById('choice-answers');
                const inputArea = document.getElementById('input-area');
                const handwritingArea = document.getElementById('handwriting-area');
                const wordArrangeArea = document.getElementById('word-arrange-area');
                const trueFalseArea = document.getElementById('true-false-area');

                globalSettings.answerMode = this.value;
                
                // 英単語並び替えモードが選択された場合のチェック
                if (this.value === 'word-arrange') {
                    // 問題データが読み込まれているかチェック
                    if (questions && questions.length > 0) {
                        const isEnglishSet = isProblemSetEnglish();
                        
                        if (!isEnglishSet) {
                            notie.alert({
                                type: 'warning',
                                text: '英単語並び替えモードは英単語問題でのみ利用可能です。4択モードに変更しました。',
                                time: 3
                            });
                            document.getElementById('choice-mode').checked = true;
                            globalSettings.answerMode = 'choice';
                        }
                    } else {
                        // 問題データがまだ読み込まれていない場合は、後でチェックする
                        // loadQuestions完了後にcheckAndControlEnglishOnlyFeaturesが呼ばれる
                    }
                }
                
                saveSettings();

                // モード切り替え時に入力フィールドをクリア
                clearAllInputFields();

                // すべてのエリアを非表示にする
                choiceArea.style.display = 'none';
                inputArea.style.display = 'none';
                handwritingArea.style.display = 'none';
                wordArrangeArea.style.display = 'none';
                trueFalseArea.style.display = 'none';

                if (globalSettings.answerMode === 'choice') {
                    choiceArea.style.display = 'block';
                } else if (globalSettings.answerMode === 'input') {
                    inputArea.style.display = 'block';
                    document.getElementById('text-answer').focus();
                } else if (globalSettings.answerMode === 'handwriting') {
                    handwritingArea.style.display = 'block';
                    // 手書きモード初期化処理（必要なら）
                    if (window.clearCanvas) {
                        clearCanvas();
                    }
                } else if (globalSettings.answerMode === 'word-arrange') {
                    wordArrangeArea.style.display = 'block';
                } else if (globalSettings.answerMode === 'true-false') {
                    trueFalseArea.style.display = 'block';
                }

                // 現在問題画面が表示されている場合は問題を再表示
                if (swiper.activeIndex === 1) {
                    await showNextQuestion();
                    // モード切り替え時にタイマーを再開始
                    start = performance.now();
                }
            });
        });
        // テキスト回答送信
        document.getElementById('submit-text-answer').addEventListener('click',
            function () {
                const answer = document.getElementById('text-answer').value.trim();
                if (answer) {
                    checkTextAnswer(answer);
                }
            });

        // テキスト回答のEnterキー処理
        document.getElementById('text-answer').addEventListener('keypress', function (e) {
            if (e.key === 'Enter') {
                const answer = this.value.trim();
                if (answer) {
                    checkTextAnswer(answer);
                }
            }
        });

        // 正解時の処理 (入力/手書きモード用)
        async function handleCorrectAnswerInput() {
            if (typeof start === 'undefined' || start === null) {
                start = performance.now();
            }
            const endTime = performance.now();
            const timeTaken = endTime - start;
            answerTimes.push(timeTaken);
            start = null;

            if (!questionStats.has(currentIndex)) {
                questionStats.set(currentIndex, {
                    attempts: 0,
                    correctAnswers: 0,
                    averageTime: 0,
                    isLongTime: false,
                    isWrong: false
                });
            }

            const stats = questionStats.get(currentIndex);
            stats.attempts++;
            stats.averageTime = ((stats.averageTime || 0) * (stats.attempts - 1) +
                timeTaken) / stats.attempts;
            stats.isWrong = false

            answeredQuestions.add(currentIndex);
            totalCount++;
            correctCount++;
            renzokuseikai++;

            if (renzokuseikai > maxStreak) {
                maxStreak = renzokuseikai;
            }

            stats.correctAnswers = (stats.correctAnswers || 0) + 1;
            const avgTime = calculateAverageTime();
            const isLongTime = timeTaken / 1000 > Math.max(5, avgTime * 1.5);
            stats.isLongTime = isLongTime || stats.isLongTime;

            // 正解回数2回以上、かつ時間がかかっていない場合に学習中から外す
            if (stats.correctAnswers >= 2 && !stats.isLongTime) {
                studyingQuestions.delete(currentIndex);
            } else if (stats.correctAnswers >= 1 && isLongTime) {
                studyingQuestions.add(currentIndex); // 時間がかかったら学習中に戻す
            }


            notie.alert({
                type: 1,
                text: '正解',
                time: 1
            });
            
            // 発音機能：正解の英単語を発音
            const isReversed = globalSettings.replaceMondai;
            const correctAnswer = isReversed ? questions[currentIndex].description :
                questions[currentIndex].word;
            playCorrectAnswerPronunciation(correctAnswer);
            
            updateProgressDisplay();
            updateStats();

            // 入力フィールド/キャンバスをクリア
            document.getElementById('text-answer').value = '';
            if (window.clearCanvas) clearCanvas(); // write.js の関数があれば呼ぶ

            sendScore("add_correct", accid, password);
            await saveProgressToServer(); // 進捗保存

            nextIndex();
            await showNextQuestion();
        }


        // 不正解時の処理 (入力/手書きモード用)
        async function handleWrongAnswerInput(userAnswer, correctAnswer) {
            if (typeof start === 'undefined' || start === null) {
                start = performance.now();
            }
            const endTime = performance.now();
            const timeTaken = endTime - start;
            answerTimes.push(timeTaken);
            start = null; // タイマーリセット

            if (!questionStats.has(currentIndex)) {
                questionStats.set(currentIndex, {
                    attempts: 0,
                    correctAnswers: 0,
                    averageTime: 0,
                    isLongTime: false,
                    isWrong: false
                });
            }

            const stats = questionStats.get(currentIndex);
            stats.attempts++;
            stats.averageTime = ((stats.averageTime || 0) * (stats.attempts - 1) +
                timeTaken) / stats.attempts;
            stats.isWrong = true; // 不正解フラグ

            answeredQuestions.add(currentIndex);
            totalCount++;
            wrongCount++;
            renzokuseikai = 0;
            studyingQuestions.add(currentIndex); // 不正解なら必ず学習中リストへ

            const avgTime = calculateAverageTime();
            const isLongTime = timeTaken / 1000 > Math.max(5, avgTime * 1.5);
            stats.isLongTime = isLongTime || stats.isLongTime; // 時間がかかったかも記録

            notie.force({
                type: 'error',
                text: '<div class="popup">正しい回答: ' + correctAnswer + '<br>あなたの回答: ' +
                    userAnswer + '</div>',
                buttonText: '私は間違えたことを深くお詫び、反省することを誓います。',
                callback: async function () { // Make callback async
                    // 入力フィールド/キャンバスはクリアしない（間違いを確認できるように）
                    // document.getElementById('text-answer').value = '';
                    // if (window.clearCanvas) clearCanvas();

                    updateProgressDisplay();
                    updateStats();

                    sendScore("add_bad", accid, password);
                    await saveProgressToServer(); // 進捗保存

                    // 不正解時は同じ問題を表示 (nextIndexを呼ばない)
                    await showNextQuestion();
                }
            });
        }


        // テキスト回答の正誤チェック
        function checkTextAnswer(answer) {
            const isReversed = globalSettings.replaceMondai;
            const correctAnswer = isReversed ? questions[currentIndex].description :
                questions[currentIndex].word;

            // 完全一致で比較
            if (answer === correctAnswer) {
                handleCorrectAnswerInput();
            } else {
                // ひらがな・カタカナ、全角・半角の違いなどを許容する場合はここで処理を追加
                // 例: normalizeAnswer(answer) === normalizeAnswer(correctAnswer)
                handleWrongAnswerInput(answer, correctAnswer);
            }
        }


        // 手書き回答の送信処理 (write.js側で checkHandwritingAnswer を呼ぶ想定)
        function checkHandwritingAnswer(handwritingResult) {
            const isReversed = globalSettings.replaceMondai;
            const correctAnswer = isReversed ? questions[currentIndex].description :
                questions[currentIndex].word;

            // 手書き認識結果 (handwritingResult) と正解 (correctAnswer) を比較
            // 認識結果が複数候補ある場合は、いずれかが一致すれば正解とするなどの処理が必要
            // ここでは単純に最初の候補と比較する例
            if (handwritingResult && handwritingResult.length > 0 && handwritingResult[0] ===
                correctAnswer) {
                handleCorrectAnswerInput();
            } else {
                handleWrongAnswerInput(handwritingResult ? handwritingResult.join(', ') :
                    '認識失敗', correctAnswer);
            }
        }

        // 英単語並び替えモードのセットアップ
        async function setupWordArrangeMode(correctAnswer) {
            
            // 正解の文章を保存（デフォルト値を設定）
            window.correctSentence = correctAnswer;
            window.arrangedWords = [];
            
            // シャッフルされた単語を表示するコンテナを取得
            const shuffledContainer = document.getElementById('shuffled-words');
            const arrangedContainer = document.getElementById('arranged-words');
            
            if (!shuffledContainer || !arrangedContainer) {
                return;
            }
            
            // ハードモードの処理を参考に、英単語から文章を取得
            try {
                const response = await fetch('/api/get/sentences', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        words: [correctAnswer]
                    })
                });

                if (response.ok) {
                    const sentenceData = await response.json();
                    
                    if (sentenceData.results && sentenceData.results[correctAnswer] &&
                        sentenceData.results[correctAnswer].length > 0) {
                        const sentences = sentenceData.results[correctAnswer];
                        const selectedSentence = sentences[Math.floor(Math.random() * sentences.length)];
                        const parts = selectedSentence.split("|");
                        window.correctSentence = parts[1] || selectedSentence;
                        window.japaneseText = parts[0] || null;

                    } else {
                        // 文章が見つからない場合は、正解の単語を使った簡単な文を作成
                        window.correctSentence = `This is a ${correctAnswer}.`;
                    }
                } else {
                    throw new Error(`API request failed with status ${response.status}`);
                }
            } catch (error) {
                // エラーの場合は単語そのものまたは簡単な文を使用
                if (correctAnswer.includes(' ')) {
                    window.correctSentence = correctAnswer;
                } else {
                    window.correctSentence = `This is a ${correctAnswer}.`;
                }
            }
            
            // 文章を単語に分割（句読点は除外）
            const words = window.correctSentence.match(/\b\w+\b/g) ||
                         window.correctSentence.split(/\s+/).filter(word => word.trim() !== '' && !/^[.,!?;:]$/.test(word));
            
            if (words.length === 0) {
                return;
            }
            
            // 単語をシャッフル
            const shuffledWords = [...words].sort(() => Math.random() - 0.5);

            // シャッフルされた単語を表示
            shuffledContainer.innerHTML = '';

            shuffledWords.forEach((word, index) => {
                const wordChip = document.createElement('button');
                wordChip.className = 'word-chip';
                wordChip.textContent = word;
                wordChip.dataset.word = word;
                wordChip.dataset.originalIndex = index;
                wordChip.onclick = () => moveWordToArranged(wordChip);
                setupDragAndDrop(wordChip);
                shuffledContainer.appendChild(wordChip);
            });

            // 並び替えエリアをリセット
            arrangedContainer.innerHTML = '<div class="arranged-placeholder">ここに単語をタップして配置</div>';
            
            // コンテナのドラッグイベントを設定
            setupContainerDragEvents();
            
            // 問題文を更新
            const questionElement = document.getElementById('question');
            if (window.japaneseText) {
                questionElement.innerHTML =
                    `<div>次の日本語を英語に直して、正しい語順に並び替えてください：</div><br><div><em>${window.japaneseText}</em></div>`;
            } else {
                questionElement.innerHTML =
                    `<div>次の英文を正しい語順に並び替えてください：</div><br><div><em>${window.correctSentence}</em></div>`;
            }
        }

        // 単語を並び替えエリアに移動
        function moveWordToArranged(wordChip) {
            const arrangedContainer = document.getElementById('arranged-words');
            const placeholder = arrangedContainer.querySelector('.arranged-placeholder');

            // プレースホルダーを削除
            if (placeholder) {
                placeholder.remove();
            }

            // 単語を並び替えエリアに追加
            const arrangedChip = wordChip.cloneNode(true);
            arrangedChip.className = 'word-chip arranged';
            arrangedChip.onclick = () => moveWordBackToShuffled(arrangedChip);
            setupDragAndDrop(arrangedChip);
            arrangedContainer.appendChild(arrangedChip);

            // 元の単語を削除
            wordChip.remove();

            // 配置された単語を記録
            window.arrangedWords.push(arrangedChip.dataset.word);
        }

        // 単語をシャッフルエリアに戻す
        function moveWordBackToShuffled(arrangedChip) {
            const shuffledContainer = document.getElementById('shuffled-words');
            const arrangedContainer = document.getElementById('arranged-words');

            // 単語をシャッフルエリアに戻す
            const shuffledChip = arrangedChip.cloneNode(true);
            shuffledChip.className = 'word-chip';
            shuffledChip.onclick = () => moveWordToArranged(shuffledChip);
            setupDragAndDrop(shuffledChip);
            shuffledContainer.appendChild(shuffledChip);

            // 並び替えエリアから削除
            arrangedChip.remove();

            // 記録から削除
            const wordIndex = window.arrangedWords.indexOf(arrangedChip.dataset.word);
            if (wordIndex > -1) {
                window.arrangedWords.splice(wordIndex, 1);
            }

            // プレースホルダーを表示するかチェック
            if (window.arrangedWords.length === 0) {
                arrangedContainer.innerHTML =
                    '<div class="arranged-placeholder">ここに単語をタップして配置</div>';
            }
        }

        // 並び替え回答をリセット
        async function clearWordArrangement() {
            const isReversed = globalSettings.replaceMondai;
            const correctAnswer = isReversed ? questions[currentIndex].description :
                questions[currentIndex].word;
            await setupWordArrangeMode(correctAnswer);
        }

        // 並び替え回答を送信
        function submitWordArrangement() {
            if (!window.arrangedWords || window.arrangedWords.length === 0) {
                alert('単語を配置してください');
                return;
            }

            const userAnswer = window.arrangedWords.join(' ');
            const correctAnswer = window.correctSentence || questions[currentIndex].word;

            // 句読点を除外した比較
            const normalizeText = (text) => {
                return text.replace(/[.,!?;:]/g, '').replace(/\s+/g, ' ').trim().toLowerCase();
            };

            const isCorrect = normalizeText(userAnswer) === normalizeText(correctAnswer);

            if (isCorrect) {
                handleCorrectAnswerInput();
            } else {
                handleWrongAnswerInput(userAnswer, correctAnswer);
            }
        }

        // ドラッグアンドドロップ機能のセットアップ
        function setupDragAndDrop(element) {
            if (!element) return;
            
            element.draggable = true;
            
            // 重複を避けるため、一度リスナーをクリア
            element.onmousedown = null;
            element.ondragstart = null;
            element.ondragend = null;
            
            element.addEventListener('dragstart', handleDragStart, { passive: false });
            element.addEventListener('dragend', handleDragEnd, { passive: false });
            
            // タッチデバイス対応
            element.addEventListener('touchstart', handleTouchStart, { passive: false });
            element.addEventListener('touchmove', handleTouchMove, { passive: false });
            element.addEventListener('touchend', handleTouchEnd, { passive: false });
        }

        let draggedElement = null;
        let dragStartContainer = null;
        let touchStartX = 0;
        let touchStartY = 0;
        let isDragging = false;

        function handleDragStart(e) {
            draggedElement = e.target;
            dragStartContainer = e.target.parentElement;
            e.target.classList.add('dragging');
            
            // データ転送の設定
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/plain', e.target.dataset.word || e.target.textContent);
        }

        function handleDragEnd(e) {
            if (e.target) {
                e.target.classList.remove('dragging');
            }
            
            // すべての視覚的フィードバックをクリア
            clearDragFeedback();
            
            draggedElement = null;
            dragStartContainer = null;
            isDragging = false;
        }

        // タッチイベントハンドラー
        function handleTouchStart(e) {
            const touch = e.touches[0];
            touchStartX = touch.clientX;
            touchStartY = touch.clientY;
            draggedElement = e.target;
            dragStartContainer = e.target.parentElement;
        }

        function handleTouchMove(e) {
            if (!draggedElement) return;
            
            e.preventDefault();
            const touch = e.touches[0];
            const deltaX = Math.abs(touch.clientX - touchStartX);
            const deltaY = Math.abs(touch.clientY - touchStartY);
            
            // ドラッグ開始の閾値
            if (deltaX > 10 || deltaY > 10) {
                isDragging = true;
                draggedElement.classList.add('dragging');
                
                // タッチ位置の要素を取得
                const elementBelow = document.elementFromPoint(touch.clientX, touch.clientY);
                handleTouchDrop(elementBelow);
            }
        }

        function handleTouchEnd(e) {
            if (isDragging && draggedElement) {
                const touch = e.changedTouches[0];
                const elementBelow = document.elementFromPoint(touch.clientX, touch.clientY);
                
                if (elementBelow) {
                    handleTouchDrop(elementBelow);
                }
            }
            
            handleDragEnd(e);
        }

        function handleTouchDrop(targetElement) {
            if (!draggedElement || !targetElement) return;
            
            const targetContainer = targetElement.closest('.shuffled-words-container, .arranged-words-container');
            if (targetContainer) {
                performWordMove(targetContainer, targetElement);
            }
        }

        function clearDragFeedback() {
            document.querySelectorAll('.word-chip').forEach(chip => {
                chip.classList.remove('drag-over', 'insert-before', 'insert-after', 'dragging');
            });
            document.querySelectorAll('.shuffled-words-container, .arranged-words-container').forEach(container => {
                container.classList.remove('drag-over');
            });
        }

        function performWordMove(targetContainer, targetElement) {
            if (!draggedElement || !targetContainer) return;
            
            // 同じ要素にドロップした場合は何もしない
            if (draggedElement === targetElement) return;
            
            const isTargetArranged = targetContainer.classList.contains('arranged-words-container');
            const isDraggedFromArranged = draggedElement.classList.contains('arranged');
            
            // プレースホルダーを削除
            const placeholder = targetContainer.querySelector('.arranged-placeholder');
            if (placeholder) {
                placeholder.remove();
            }
            
            if (isTargetArranged) {
                // 並び替えエリアへの移動
                if (isDraggedFromArranged) {
                    // 同じエリア内での順序変更
                    const targetChip = targetElement && targetElement.classList.contains('word-chip') ? targetElement : null;
                    if (targetChip) {
                        targetContainer.insertBefore(draggedElement, targetChip.nextSibling);
                    } else {
                        targetContainer.appendChild(draggedElement);
                    }
                    updateArrangedWordsArray();
                } else {
                    // シャッフルエリアから並び替えエリアへ
                    moveWordToArrangedFromDrag(draggedElement, targetContainer, targetElement);
                }
            } else {
                // シャッフルエリアへ戻す
                if (isDraggedFromArranged) {
                    moveWordBackToShuffledFromDrag(draggedElement, targetContainer);
                }
            }
        }

        function moveWordToArrangedFromDrag(wordChip, targetContainer, targetElement) {
            const arrangedChip = wordChip.cloneNode(true);
            arrangedChip.className = 'word-chip arranged';
            arrangedChip.onclick = () => moveWordBackToShuffled(arrangedChip);
            setupDragAndDrop(arrangedChip);
            
            if (targetElement && targetElement.classList.contains('word-chip')) {
                targetContainer.insertBefore(arrangedChip, targetElement.nextSibling);
            } else {
                targetContainer.appendChild(arrangedChip);
            }
            
            // 元の単語を削除
            wordChip.remove();
            
            // 配置された単語を記録
            updateArrangedWordsArray();
        }

        function moveWordBackToShuffledFromDrag(arrangedChip, targetContainer) {
            const shuffledChip = arrangedChip.cloneNode(true);
            shuffledChip.className = 'word-chip';
            shuffledChip.onclick = () => moveWordToArranged(shuffledChip);
            setupDragAndDrop(shuffledChip);
            targetContainer.appendChild(shuffledChip);
            
            // 並び替えエリアから削除
            arrangedChip.remove();
            
            // 記録から削除
            const wordIndex = window.arrangedWords.indexOf(arrangedChip.dataset.word);
            if (wordIndex > -1) {
                window.arrangedWords.splice(wordIndex, 1);
            }
            
            // プレースホルダーを表示するかチェック
            checkAndAddPlaceholder();
        }

        // 並び替えられた単語の配列を更新
        function updateArrangedWordsArray() {
            const arrangedContainer = document.getElementById('arranged-words');
            const chips = arrangedContainer.querySelectorAll('.word-chip.arranged');
            window.arrangedWords = Array.from(chips).map(chip => chip.dataset.word);
        }

        // プレースホルダーが必要かチェックして追加
        function checkAndAddPlaceholder() {
            const arrangedContainer = document.getElementById('arranged-words');
            const chips = arrangedContainer.querySelectorAll('.word-chip.arranged');
            
            if (chips.length === 0) {
                arrangedContainer.innerHTML = '<div class="arranged-placeholder">ここに単語をタップして配置</div>';
            }
        }

        // コンテナのドロップ機能を設定
        function setupContainerDragEvents() {
            const shuffledContainer = document.getElementById('shuffled-words');
            const arrangedContainer = document.getElementById('arranged-words');
            
            [shuffledContainer, arrangedContainer].forEach(container => {
                if (container) {
                    // 既存のリスナーをクリア
                    container.removeEventListener('dragover', handleContainerDragOver);
                    container.removeEventListener('drop', handleContainerDrop);
                    container.removeEventListener('dragenter', handleContainerDragEnter);
                    container.removeEventListener('dragleave', handleContainerDragLeave);
                    
                    // 新しいリスナーを追加
                    container.addEventListener('dragover', handleContainerDragOver);
                    container.addEventListener('drop', handleContainerDrop);
                    container.addEventListener('dragenter', handleContainerDragEnter);
                    container.addEventListener('dragleave', handleContainerDragLeave);
                }
            });
        }

        function handleContainerDragOver(e) {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';
            e.currentTarget.classList.add('drag-over');
        }

        function handleContainerDragEnter(e) {
            e.preventDefault();
        }

        function handleContainerDragLeave(e) {
            if (!e.currentTarget.contains(e.relatedTarget)) {
                e.currentTarget.classList.remove('drag-over');
            }
        }

        function handleContainerDrop(e) {
            e.preventDefault();
            e.currentTarget.classList.remove('drag-over');
            
            if (draggedElement) {
                performWordMove(e.currentTarget, null);
            }
        }

        // すべての入力フィールドとモード固有の状態をクリアする関数
        function clearAllInputFields() {
            // テキスト入力フィールドをクリア
            const textInput = document.getElementById('text-answer');
            if (textInput) {
                textInput.value = '';
            }

            // 手書きキャンバスをクリア
            if (window.clearCanvas) {
                clearCanvas();
            }

            // 英単語並び替えモードの状態をクリア
            clearWordArrangeState();

            // ○×問題モードの状態をクリア
            if (window.trueFalseCorrectAnswer !== undefined) {
                delete window.trueFalseCorrectAnswer;
            }
        }

        // 英単語並び替えモードの状態をクリアする関数
        function clearWordArrangeState() {
            // グローバル変数をクリア
            if (window.correctSentence !== undefined) {
                delete window.correctSentence;
            }
            if (window.arrangedWords !== undefined) {
                delete window.arrangedWords;
            }
            if (window.japaneseText !== undefined) {
                delete window.japaneseText;
            }

            // DOMをクリア
            const shuffledContainer = document.getElementById('shuffled-words');
            const arrangedContainer = document.getElementById('arranged-words');
            
            if (shuffledContainer) {
                shuffledContainer.innerHTML = '';
            }
            
            if (arrangedContainer) {
                arrangedContainer.innerHTML = '<div class="arranged-placeholder">ここに単語をタップして配置</div>';
            }

            // ドラッグ関連の状態をクリア
            if (draggedElement) {
                draggedElement.classList.remove('dragging');
                draggedElement = null;
            }
            dragStartContainer = null;
            isDragging = false;
            
            // 視覚的フィードバックをクリア
            clearDragFeedback();
        }

        // 回答モードに応じてUIをセットアップする関数
        function setupAnswerModeUI(correctAnswer) {
            const choiceArea = document.getElementById('choice-answers');
            const inputArea = document.getElementById('input-area');
            const handwritingArea = document.getElementById('handwriting-area');
            const wordArrangeArea = document.getElementById('word-arrange-area');
            const trueFalseArea = document.getElementById('true-false-area');

            // すべてのエリアを非表示にする
            choiceArea.style.display = 'none';
            inputArea.style.display = 'none';
            handwritingArea.style.display = 'none';
            wordArrangeArea.style.display = 'none';
            trueFalseArea.style.display = 'none';

            // 現在のモードに応じて該当エリアを表示し、必要な初期化を行う
            switch (globalSettings.answerMode) {
                case 'choice':
                    choiceArea.style.display = 'block';
                    break;

                case 'input':
                    inputArea.style.display = 'block';
                    // テキスト入力フィールドをクリア
                    document.getElementById('text-answer').value = '';
                    break;

                case 'handwriting':
                    handwritingArea.style.display = 'block';
                    // 手書きキャンバスをクリア
                    if (window.clearCanvas) {
                        clearCanvas();
                    }
                    break;

                case 'word-arrange':
                    wordArrangeArea.style.display = 'block';
                    // 英単語並び替えモードをセットアップ
                    setupWordArrangeMode(correctAnswer);
                    break;

                case 'true-false':
                    trueFalseArea.style.display = 'block';
                    // ○×問題モードをセットアップ
                    setupTrueFalseMode(questions[currentIndex]);
                    break;

                default:
                    // デフォルトは4択モード
                    choiceArea.style.display = 'block';
                    break;
            }
        }

        // ○×問題モードのセットアップ
        function setupTrueFalseMode(question) {
            // 問題データに trueFalseAnswer プロパティがあるかチェック
            if (question.trueFalseAnswer !== undefined) {
                // 明示的に○×の正解が設定されている場合
                window.trueFalseCorrectAnswer = question.trueFalseAnswer;
            } else {
                // 設定されていない場合はランダムで決定（デモ用）
                window.trueFalseCorrectAnswer = Math.random() < 0.5;
            }
        }

        // ○×問題の回答処理
        function submitTrueFalseAnswer(userAnswer) {
            const isCorrect = userAnswer === window.trueFalseCorrectAnswer;

            if (isCorrect) {
                handleCorrectAnswerInput();
            } else {
                const answerText = userAnswer ? '○ (正しい)' : '× (間違い)';
                const correctText = window.trueFalseCorrectAnswer ? '○ (正しい)' : '× (間違い)';
                handleWrongAnswerInput(answerText, correctText);
            }
        }


        document.addEventListener('DOMContentLoaded', function () {
            if (getParam("tangolist") === 'true') {
                swiper.slideTo(2);

                const url = new URL(window.location.href);
                url.searchParams.delete('tangolist');
                window.history.replaceState({}, document.title, url);
            }

            // ローカルストレージから設定を読み込み、UIに反映
            loadSettings();

            // 回答モードの表示を切り替える
            const answerModeRadio = document.getElementById(globalSettings.answerMode +
                '-mode');
            if (answerModeRadio) {
                answerModeRadio.dispatchEvent(new Event('change'));
            }

            //タイトルの変更
            document.title = `Quizbox - ${getParam("id")}`;
        });

        // 復習モード開始ボタンのイベントリスナー
        document.getElementById('start-review-btn').addEventListener('click', async function () {
            reviewQuestions = Array.from(studyingQuestions);
            if (reviewQuestions.length === 0) {
                notie.alert({
                    type: 'info',
                    text: '復習する問題はありません。',
                    time: 2
                });
                return;
            }

            isInReviewMode = true;
            reviewStreaks = {};
            reviewQuestions.forEach(index => reviewStreaks[index] = 0); // Streaks初期化

            // 復習モードの最初の問題を設定 (ランダムに)
            if (reviewQuestions.length > 0) {
                currentIndex = reviewQuestions[Math.floor(Math.random() * reviewQuestions.length)];
            } else {
                // 念のため復習対象がない場合の処理
                isInReviewMode = false;
                notie.alert({
                    type: 'info',
                    text: 'エラー: 復習対象がありません。',
                    time: 2
                });
                return;
            }


            document.getElementById('review-mode-indicator').style.display = 'block';
            document.getElementById('exit-review-btn').style.display = 'block';
            document.getElementById('review-count').textContent = reviewQuestions.length;

            swiper.slideTo(1); // クイズ画面へ移動
            await showNextQuestion();
            updateProgressDisplay(); // 進捗表示も更新
            notie.alert({
                type: 'info',
                text: '復習モードを開始します。',
                time: 1.5
            });
            // 復習モード開始時もタイマー開始
            start = performance.now();
        });

        // 通常モードに戻るボタンのイベントリスナー
        document.getElementById('exit-review-btn').addEventListener('click', async function () {
            isInReviewMode = false;
            document.getElementById('review-mode-indicator').style.display = 'none';
            document.getElementById('exit-review-btn').style.display = 'none';
            notie.alert({
                type: 'info',
                text: '通常モードに戻りました。',
                time: 1.5
            });
            saveProgressToServer(); // 復習モード終了時に進捗保存
            selectQuestionMode(); // 通常のモード選択ロジックを再実行
            await showNextQuestion();
            updateProgressDisplay();
            // 通常モードに戻った時もタイマー開始
            start = performance.now();
        });

        // 英単語並び替えモードのイベントリスナー
        document.getElementById('clear-arrange').addEventListener('click',
            clearWordArrangement);
        document.getElementById('submit-arrange').addEventListener('click',
            submitWordArrangement);

        // ○×問題モードのイベントリスナー
        document.getElementById('true-btn').addEventListener('click', function () {
            submitTrueFalseAnswer(true);
        });

        document.getElementById('false-btn').addEventListener('click', function () {
            submitTrueFalseAnswer(false);
        });
    </script>
</body>

</html>