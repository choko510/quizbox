<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>4択クイズ</title>
    <link href="https://cdn.jsdelivr.net/npm/swiper@11.2.6/swiper-bundle.min.css" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/swiper@11.2.6/swiper-bundle.min.js"></script>
    <link rel="stylesheet" href="./style.css">
    <link rel="stylesheet" href="https://fonts.googleapis.com/earlyaccess/notosansjapanese.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css">
    <link rel="stylesheet" href="../../modal.css">
    <link href="https://cdn.jsdelivr.net/npm/notie@4.3.1/dist/notie.min.css" rel="stylesheet">
    <link rel="stylesheet" href="./word-dictionary.css">
</head>

<body>
    <a href="../" class="back"></a>
    <a href="javascript:void(0);" id="settings-btn"
        style="position: fixed; bottom: 10px; right: 10px; font-size: 20px; color: #666; z-index: 10000;"><i
            class="fas fa-cog"></i></a>
    <div class="swiper-container">
        <div class="swiper-wrapper">

            <div class="swiper-slide slide1">
                <div class="resultbox">
                    <div class="resultbox1">
                        <div class="progress-title"><i class="fas fa-book-open"></i>学習進捗</div>
                        <div id="progress-stats">
                            <div><i class="fas fa-tasks"></i>総問題数: <span id="total-questions">0</span></div>
                            <div><i class="fas fa-check-circle"></i>学習済み: <span id="answered-questions">0</span></div>
                            <div><i class="fas fa-smile"></i>正解: <span id="correct-answers">0</span></div>
                            <div><i class="fas fa-times-circle"></i>不正解: <span id="wrong-answers">0</span></div>
                            <div>
                                <i class="fas fa-chart-pie"></i>進捗率: <span id="progress-percentage">0</span>%
                                <div class="progress-bar-container">
                                    <div class="progress-bar" id="progress-bar" style="width: 0%"></div>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="resultbox2">
                        <div class="stats-title"><i class="fas fa-chart-bar"></i>統計情報</div>
                        <div id="performance-stats">
                            <div><i class="fas fa-percentage"></i>平均正解率: <span id="avg-accuracy">0</span>%</div>
                            <div><i class="fas fa-trophy"></i>最高連続正解: <span id="max-streak">0</span></div>
                            <div><i class="fas fa-fire"></i>現在の連続正解: <span id="current-streak">0</span></div>
                            <div><i class="fas fa-stopwatch"></i>平均解答時間: <span id="avg-time">0</span>秒</div>
                        </div>
                    </div>
                    <div class="resultbox3">
                        <div class="study-title"><i class="fas fa-exclamation-circle"></i>学習中の問題</div>
                        <ul id="study-list"></ul>
                        <button id="start-review-btn"
                            style="margin-bottom: 10px; padding: 8px 15px; background-color: #28a745; color: white; border: none; border-radius: 5px; cursor: pointer;">間違えた問題を復習する</button>

                    </div>
                    <div class="resultbox4">
                        <canvas id="performance-chart"></canvas>
                    </div>
                </div>
            </div>

            <div class="swiper-slide slide2">
                <div class="main">
                    <div id="review-mode-indicator"
                        style="display: none; color: red; font-weight: bold; text-align: center; margin-bottom: 10px;">
                        復習モード中 (残り <span id="review-count">0</span> 問)</div>

                    <div class="title">
                        <div id="question"></div>
                    </div>
                    <ul class="sp" id="choice-answers">
                        <li><button id="answer1"></button></li>
                        <li><button id="answer2"></button></li>
                        <li><button id="answer3"></button></li>
                        <li><button id="answer4"></button></li>
                    </ul>

                    <div id="input-area" style="display: none;" class="no-swiping">
                        <input type="text" id="text-answer" placeholder="回答を入力">
                        <button id="submit-text-answer">回答</button>
                    </div>

                    <div id="handwriting-area" style="display: none;" class="no-swiping">
                        <div class="canvas-container no-swiping">
                            <canvas id="handwriting-canvas" width="400" height="200" class="no-swiping"></canvas>
                        </div>
                        <div class="handwriting-controls no-swiping">
                            <button id="clear-canvas" class="handwriting-btn">クリア</button>
                            <button id="submit-answer" class="handwriting-btn">回答する</button>
                        </div>
                    </div>
                </div>
                <div id="score">
                    回答数: 0 正解数: 0 不正解数: 0 連続正解数:0 正答率: 0%
                </div>
                <button id="exit-review-btn"
                    style="display: none; position: fixed; bottom: 50px; right: 10px; padding: 8px 15px; background-color: #6c757d; color: white; border: none; border-radius: 5px; cursor: pointer; z-index: 9999;">通常モードに戻る</button>

            </div>

            <div class="swiper-slide slide3">
                <div class="tangolist">
                    <h1>単語リスト</h1>
                    <div class="search-container">
                        <input type="text" class="searchbox" placeholder="検索" oninput="filterWords()">
                        <i class="fas fa-search search-icon"></i>
                        <div class="filter-options">
                            <select id="answerFilter" onchange="filterWords()">
                                <option value="all">すべての問題</option>
                                <option value="unanswered">未回答の問題</option>
                                <option value="correct">正解した問題</option>
                                <option value="incorrect">間違えた問題</option>
                            </select>
                        </div>
                    </div>
                    <ul id="wordList" class="custom-list"></ul>
                </div>
            </div>
        </div>
        <div class="swiper-button-next"></div>
        <div class="swiper-button-prev"></div>
    </div>

    <div class="modal micromodal-slide" id="modal-1" aria-hidden="true">
        <div class="modal__overlay" tabindex="-1" data-micromodal-close>
            <div class="modal__container" role="dialog" aria-modal="true" aria-labelledby="modal-1-title">
                <main class="modal__content" id="modal-1-content">
                    <div id="hansei" style="text-align: center;"></div>
                    <hr>
                    <div id="kaisetu"></div>
                </main>
                <footer class="modal__footer" style="text-align: center;justify-content: center;align-items: center;">
                    <button class="modal__btn" data-micromodal-close
                        aria-label="Close this dialog window">私は間違えたことを深くお詫び、反省することを誓います。</button>
                </footer>
            </div>
        </div>
    </div>

    <div class="modal micromodal-slide" id="settings-modal" aria-hidden="true">
        <div class="modal__overlay" tabindex="-1" data-micromodal-close>
            <div class="modal__container" role="dialog" aria-modal="true" aria-labelledby="settings-modal-title">
                <header class="modal__header" style="text-align: center;">
                    <h2 id="settings-modal-title">設定</h2>
                </header>
                <main class="modal__content" id="settings-modal-content">
                    <div class="settings-section">
                        <h3>出題方法</h3>
                        <div class="settings-option">
                            <input type="checkbox" name="replace-mondai" id="replace-mondai">
                            <label for="replace-mondai">問題文と回答文を入れ換える</label>
                        </div>

                        <div class="settings-option">
                            <input type="checkbox" name="hardmode" id="hardmode">
                            <label for="hardmode">ハードモード</label>
                        </div>

                        <h3>出題順序</h3>
                        <div class="settings-option">
                            <input type="radio" id="random-mode" name="question-mode" value="random" checked>
                            <label for="random-mode">ランダムに出題</label>
                        </div>
                        <div class="settings-option">
                            <input type="radio" id="sequential-mode" name="question-mode" value="sequential">
                            <label for="sequential-mode">1問目から順に出題</label>
                        </div>

                        <h3>回答モード</h3>
                        <div class="settings-option">
                            <input type="radio" id="choice-mode" name="answer-mode" value="choice" checked>
                            <label for="choice-mode">4択モード</label>
                        </div>

                        <div class="settings-option">
                            <input type="radio" id="input-mode" name="answer-mode" value="input">
                            <label for="input-mode">入力モード</label>
                        </div>

                        <div class="settings-option">
                            <input type="radio" id="handwriting-mode" name="answer-mode" value="handwriting" checked>
                            <label for="handwriting-mode">手書きモード(Beta)</label>
                        </div>
                        <h3>リスニングモード</h3>
                        <a href="javascript:window.location.replace(`/listening?id=${encodeURIComponent(mondai)}`);"
                            style="color: black;text-decoration:none;">リスニングモードに移動</a>
                    </div>
                </main>
                <footer class="modal__footer" style="text-align: center;">
                    <button class="modal__btn" data-micromodal-close aria-label="Close this dialog window">閉じる</button>
                </footer>
            </div>
        </div>
    </div>

    <audio id="audioPlayer" style="display:none;"></audio>
    <script src="https://cdn.jsdelivr.net/npm/micromodal@0.6.1/dist/micromodal.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/notie@4.3.1/dist/notie.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/js-cookie@3.0.5/dist/js.cookie.min.js"></script>
    <script src="./search.js"></script>
    <script src="./write.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js" defer></script>
    <script>
        const swiper = new Swiper(".swiper-container", {
            direction: "horizontal",
            loop: false,
            initialSlide: 1,
            navigation: {
                nextEl: ".swiper-button-next",
                prevEl: ".swiper-button-prev",
            },
            mousewheel: false,
            noSwiping: true,
            noSwipingClass: "no-swiping",
        });

        let start;

        swiper.on('slideChangeTransitionEnd', function () {
            if (swiper.activeIndex === 1) {
                start = performance.now();
            }
            document.querySelector('.swiper-button-next').style.display = 'block';
            document.querySelector('.swiper-button-prev').style.display = 'block';
        });


        function getParam(name, url) {
            if (!url) url = window.location.href;
            name = name.replace(/[\[\]]/g, "\\$&");
            var regex = new RegExp("[?&]" + name + "(=([^&#]*)|&|#|$)"),
                results = regex.exec(url);
            if (!results) return null;
            if (!results[2]) return '';
            return decodeURIComponent(results[2].replace(/\+/g, " "));
        }

        let mondai = getParam("id");
        const isItpass = window.location.pathname.includes('/itpasu/');
        let isCustom = false;
        let accid = Cookies.get('id');
        let password = Cookies.get('password');

        if (mondai == null) {
            let mondaiuserid = getParam("userid");
            let mondainame = getParam("name");
            if (mondaiuserid != null && mondainame != null) {
                isCustom = true;
                mondai = mondainame;
            } else {
                mondai = isItpass ? "it" : "hard";  //デフォルトの問題
            }
        }
        const questions = [];  // Initialize questions array

        let answeredQuestions = new Set();
        let maxStreak = 0;
        let performanceHistory = [];
        let performanceChart = null;
        let questionStats = new Map();
        let answerTimes = [];
        let studyingQuestions = new Set();

        let isInReviewMode = false;
        let reviewQuestions = [];
        let reviewStreaks = {}; // { questionIndex: streakCount }


        // 解説表示用の関数 (ITパスポート試験用)
        function onDontKnowClick() {
            if (isItpass) {
                const currentQuestion = questions[currentIndex];
                document.getElementById('hansei').innerHTML = `<div class="popup">${currentQuestion.description}<br><br>正解: ${currentQuestion.word}</div>`;
                document.getElementById('kaisetu').innerHTML = currentQuestion.kaisetu;
                MicroModal.show('modal-1'); // モーダルを表示
            }
        }

        // 音声再生用の関数
        function playWord(word) {
            const audioPlayer = document.getElementById('audioPlayer');
            audioPlayer.src = `/api/gen/speak/${encodeURIComponent(word)}`;
            audioPlayer.play().catch(e => console.error('音声再生エラー:', e));
        }

        function loadQuestions() {
            const showErrorMessage = (errorMessage) => {
                notie.force({
                    type: 'error',
                    text: errorMessage,
                    buttonText: '閉じる',
                    callback: function () {
                        // エラーメッセージ表示後に実行する処理（例：トップページへのリダイレクト）
                        window.location.href = "../";
                    }
                });
                // タイトル領域にもエラーメッセージを表示
                document.getElementById('question').innerHTML = `
                    <div class="error-message">
                        <i class="fas fa-exclamation-triangle"></i>
                        <p>${errorMessage}</p>
                        <button onclick="window.location.href='../'">トップページへ戻る</button>
                    </div>
                `;
            };

            const checkResponse = (response, source) => {
                if (!response.ok) {
                    if (response.status === 404) {
                        const errorMsg = `問題ファイルが見つかりませんでした（${source}: ${mondai}）`;
                        showErrorMessage(errorMsg);
                        throw new Error(errorMsg);
                    } else {
                        const errorMsg = `問題の読み込みに失敗しました（ステータス: ${response.status}）`;
                        showErrorMessage(errorMsg);
                        throw new Error(errorMsg);
                    }
                }
                return response;
            };

            if (isItpass) {
                return fetch("../../mondai/" + mondai + '.json')
                    .then(response => checkResponse(response, 'ITパスポート'))
                    .then(response => response.json())
                    .then(data => {
                        data.forEach(item => {
                            const realkotae = item.kotae.replace("ア", 0).replace("イ", 1).replace("ウ", 2).replace("エ", 3);
                            let imageHTML = '';
                            if (item.mondaiimg && item.mondaiimg.length > 0) {
                                imageHTML = item.mondaiimg.map(imgPath => `<img src="../../img/${imgPath}" alt="問題画像" class="mondai-image">`).join('');
                            }
                            const mondaiCopy = [...item.mondai];
                            mondaiCopy.splice(realkotae, 1);
                            questions.push({
                                word: item.mondai[realkotae],  // 正解の選択肢
                                description: item.mondaibun + "<br>" + imageHTML,
                                kouho: item.kouho,
                                mondai: mondaiCopy, //不正解の選択肢
                                kaisetu: item.kaisetu
                            });
                        });
                    })
                    .catch(error => {
                        console.error('問題ファイルの読み込みに失敗しました:', error);
                    });
            } else if (isCustom) {
                return fetch("/api/get/mondai/" + accid + "/" + mondai + '.json')
                    .then(response => checkResponse(response, 'カスタム問題'))
                    .then(response => response.json())
                    .then(data => {
                        data.forEach(item => {
                            if (item.mondai == undefined) {
                                questions.push({
                                    word: item.word,
                                    description: item.description,
                                });
                            } else {
                                questions.push({
                                    word: item.word,
                                    description: item.description,
                                    mondai: item.mondai
                                });
                            }
                        });
                    })
                    .catch(error => {
                        console.error('カスタム問題の読み込みに失敗しました:', error);
                    });
            } else {
                // URLから開始と終了の問題番号を取得
                const startNum = parseInt(getParam("start")) || 1;
                const endNum = parseInt(getParam("end")) || null;
                // APIから範囲指定で問題を取得
                const apiUrl = `/api/get/mondai/${mondai}.json?start=${startNum - 1}${endNum && endNum >= startNum ? `&end=${endNum}` : ''}`;
                return fetch(apiUrl)
                    .then(response => checkResponse(response, '範囲指定問題API'))
                    .then(response => response.json())
                    .then(data => {
                        data.forEach(item => {
                            const [word, description, mondaiData] = item.split('|');
                            if (mondaiData === undefined) {
                                questions.push({ word, description });
                            } else {
                                questions.push({ word, description, mondai: JSON.parse(mondaiData) });
                            }
                        });
                    })
                    .catch(error => {
                        console.error('APIによる問題の読み込みに失敗しました:', error);
                    });
            }
        }

        loadQuestions().then(async () => {
            document.getElementById('total-questions').textContent = questions.length;

            // 問題の選択方法をモードに応じて設定
            selectQuestionMode();

            // もしログインしていれば、サーバーから学習進捗データを読み込む
            if (accid && password) {
                await loadProgressFromServer();
            }

            // 最初の問題表示と進捗更新
            showNextQuestion();
            updateProgressDisplay(); // 進捗表示を更新
            initializeChart();
            populateWordList();

            // --- タイマー制御: 初期ロード時に問題画面ならタイマー開始 ---
            if (swiper.activeIndex === 1) {
                start = performance.now();
            }
            // --- タイマー制御ここまで ---


            // 検索インデックスを事前構築（バックグラウンドで実行）
            setTimeout(() => {
                buildSearchIndex();
                console.log("検索インデックスを事前構築しました");
            }, 1000);
        });

        function populateWordList() {
            let listHTML = ''; // HTML文字列を構築

            questions.forEach(question => {
                let titleHTML, contentHTML;
                const titleClass = 'tangotitle';
                const contentClass = 'content no-swiping';

                titleHTML = isItpass ? question.description : question.word;
                contentHTML = isItpass ? question.kaisetu : question.description;

                const isEnglishWord = /^[a-zA-Z0-9\s\-.,'’]+$/.test(titleHTML.trim());
                const speakerIcon = isEnglishWord
                    ? `  <i class="fas fa-volume-up speak-icon" onclick="playWord('${titleHTML}')"></i>`
                    : '';

                if (isItpass || titleHTML.endsWith("か。") || titleHTML.endsWith("答えよ。") || titleHTML.endsWith("答えなさい。")) {
                    listHTML += `<li><div class="${contentClass}">${contentHTML}${speakerIcon}</div><div class="${titleClass}">${titleHTML}</div></li>`;
                } else {
                    listHTML += `<li><div class="${titleClass}">${titleHTML}${speakerIcon}</div><div class="${contentClass}">${contentHTML}</div></li>`;
                }
            });

            document.getElementById('wordList').innerHTML = listHTML;
        }

        let currentIndex;
        let totalCount = 0;
        let correctCount = 0;
        let wrongCount = 0;
        let renzokuseikai = 0;

        function showNextQuestion() {
            if (currentIndex === undefined || currentIndex < 0 || currentIndex >= questions.length) {
                console.error("Invalid currentIndex:", currentIndex);
                if (questions.length > 0) {
                    currentIndex = 0;
                } else {
                    document.getElementById('question').innerHTML = "問題がありません。";
                    return;
                }
            }
            const question = questions[currentIndex];
            if (!question) {
                console.error("Question not found for index:", currentIndex);
                return;
            }

            const title = document.getElementById('question');
            const isReversed = localStorage.getItem('replace_mondai') === 'true';
            const isHardMode = localStorage.getItem('hard_mode') === 'true'; // ハードモード設定読み込み

            // 問題文表示
            if (isReversed) {
                title.innerHTML = question.word;
                textlength = question.word.length;
            } else {
                title.innerHTML = question.description;
                textlength = question.description.length;
            }

            // フォントサイズ調整 (既存ロジック)
            screenWidth = window.innerWidth;
            screenHeight = window.innerHeight;
            if (screenWidth < 600 || screenHeight < 600) {
                if (textlength >= 150) title.style.fontSize = "0.8em";
                else if (textlength >= 100) title.style.fontSize = "1em";
                else title.style.fontSize = "1.3em";
            } else if (screenWidth < 1200 || screenHeight < 800) {
                if (textlength >= 150) title.style.fontSize = "1em";
                else if (textlength >= 100) title.style.fontSize = "1.2em";
                else title.style.fontSize = "1.4em";
            } else {
                if (textlength >= 150) title.style.fontSize = "1.2em";
                else if (textlength >= 100) title.style.fontSize = "1.3em";
                else title.style.fontSize = "1.4em";
            }

            // --- 選択肢生成 ---
            let correctAnswer = isReversed ? question.description : question.word;
            let options = [correctAnswer]; // 正解は必ず含める
            let incorrectOptions = [];

            // 1. 不正解選択肢の候補を集める
            if (isReversed) {
                // 反転モード: 他の問題の説明文を候補に
                questions.forEach((q, index) => {
                    if (index !== currentIndex && q.description !== correctAnswer && !incorrectOptions.includes(q.description)) {
                        incorrectOptions.push(q.description);
                    }
                });
            } else {
                // 通常モード
                if (isItpass || question.mondai) {
                    // ITパスポート or mondaiフィールドあり: 指定の不正解選択肢 + 他の問題の単語
                    const providedIncorrect = isItpass ? question.mondai : (question.mondai || []);
                    providedIncorrect.forEach(opt => {
                        if (opt !== correctAnswer && !incorrectOptions.includes(opt)) {
                            incorrectOptions.push(opt);
                        }
                    });
                }
                // 他の問題の単語も候補に追加 (通常モード共通)
                questions.forEach((q, index) => {
                    if (index !== currentIndex && q.word !== correctAnswer && !incorrectOptions.includes(q.word)) {
                        incorrectOptions.push(q.word);
                    }
                });
            }

            // 2. ハードモード処理 (不正解選択肢の置き換え)
            let similarWordsUsed = 0;
            if (isHardMode && !isReversed && !isItpass) { // ハードモードは通常表示の英単語問題のみ適用 (仮)
                const similarWords = [];
                questions.forEach((q, index) => {
                    if (index !== currentIndex) {
                        const distance = calculateLevenshteinDistance(correctAnswer, q.word);
                        if (distance === 1 || distance === 2) {
                            if (q.word !== correctAnswer && !options.includes(q.word) && !similarWords.includes(q.word)) {
                                similarWords.push(q.word);
                            }
                        }
                    }
                });
                similarWords.sort(() => Math.random() - 0.5); // 似た単語候補をシャッフル

                // 不正解選択肢を似た単語で置き換える (1つまたは2つ)
                const replaceCount = Math.random() < 0.5 ? 1 : 2; // 1つか2つかランダム
                let replacedIndices = new Set(); // 置き換え済みの不正解選択肢インデックス

                while (similarWordsUsed < replaceCount && similarWords.length > 0 && incorrectOptions.length > 0) {
                    const similarWord = similarWords.shift(); // 候補から1つ取り出す
                    if (similarWord) {
                        // 置き換える不正解選択肢をランダムに選ぶ (まだ置き換えていないものから)
                        let incorrectIndexToReplace = -1;
                        let attempts = 0;
                        do {
                            incorrectIndexToReplace = Math.floor(Math.random() * incorrectOptions.length);
                            attempts++;
                        } while (replacedIndices.has(incorrectIndexToReplace) && attempts < incorrectOptions.length * 2);

                        if (!replacedIndices.has(incorrectIndexToReplace)) {
                            console.log(`Hard mode: Replacing "${incorrectOptions[incorrectIndexToReplace]}" with similar word "${similarWord}"`);
                            incorrectOptions[incorrectIndexToReplace] = similarWord; // 置き換え実行
                            replacedIndices.add(incorrectIndexToReplace);
                            similarWordsUsed++;
                        }
                    }
                }
                console.log(`Hard mode: Replaced ${similarWordsUsed} incorrect options with similar words.`);
            }

            // 3. 最終的な選択肢リストを作成 (不正解選択肢を追加)
            incorrectOptions.sort(() => Math.random() - 0.5); // 不正解候補をシャッフル
            while (options.length < 4 && incorrectOptions.length > 0) {
                const incorrectOption = incorrectOptions.shift();
                if (!options.includes(incorrectOption)) { // 重複チェック
                    options.push(incorrectOption);
                }
            }

            // 4. ダミー選択肢で埋める (もし足りなければ)
            let dummyCount = 1;
            while (options.length < 4) {
                const dummyOption = `ダミー選択肢 ${dummyCount++}`;
                if (!options.includes(dummyOption)) { // ダミーも重複しないように
                    options.push(dummyOption);
                }
            }

            // 5. 選択肢をシャッフルして表示
            options.sort(() => Math.random() - 0.5);
            options.forEach((answer, index) => {
                document.getElementById('answer' + (index + 1)).textContent = answer;
            });
            // --- 選択肢生成ここまで ---


            // --- タイマー制御: ここでのタイマー開始を削除 ---
            // start = performance.now();
            // --- タイマー制御ここまで ---

            document.getElementById('exit-review-btn').style.display = isInReviewMode ? 'block' : 'none';
            if (isInReviewMode) {
                document.getElementById('review-count').textContent = reviewQuestions.length;
            }
        }

        function calculateAccuracy() {
            return totalCount === 0 ? 0 : (correctCount / totalCount) * 100;
        }

        function calculateAverageTime() {
            if (answerTimes.length === 0) return 0;
            const sum = answerTimes.reduce((a, b) => a + b, 0);
            return (sum / answerTimes.length / 1000).toFixed(1);
        }

        function initializeChart() {
            const ctx = document.getElementById('performance-chart').getContext('2d');
            performanceChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [{
                        label: '正解率推移',
                        data: [],
                        borderColor: '#007bff',
                        tension: 0.1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            beginAtZero: true,
                            max: 100
                        }
                    }
                }
            });
        }

        function updateChart() {
            if (performanceChart && totalCount > 0) {
                const accuracy = calculateAccuracy();
                performanceHistory.push(accuracy);

                performanceChart.data.labels = Array.from({ length: performanceHistory.length }, (_, i) => i + 1);
                performanceChart.data.datasets[0].data = performanceHistory;
                performanceChart.update();
            }
        }

        function updateStudyList() {
            const studyList = document.getElementById('study-list');
            studyList.innerHTML = '';

            // studyingQuestions に含まれるインデックスの問題のみ表示
            for (let index of studyingQuestions) {
                if (!questionStats.has(index)) continue; // 統計情報がない場合はスキップ

                const stats = questionStats.get(index);
                const question = questions[index];
                const li = document.createElement('li');
                // 'wrong'クラスは不正解の場合、'long-time'は時間がかかった場合（判定ロジックは必要なら追加）
                li.className = `study-item ${stats.isWrong ? 'wrong-answer' : ''} ${stats.isLongTime ? 'long-time' : ''}`;

                let statusText = [];
                if (stats.isWrong) statusText.push('間違えた問題');
                if (stats.isLongTime) statusText.push('時間がかかった問題');

                li.innerHTML = `
                    <strong>${question.word}</strong><br>
                    <small>${statusText.join(' / ')}</small>
                `;
                studyList.appendChild(li);
            }
            // 復習ボタンの表示/非表示
            document.getElementById('start-review-btn').style.display = studyingQuestions.size > 0 ? 'block' : 'none';
        }


        function updateStats() {
            document.getElementById('answered-questions').textContent = answeredQuestions.size;
            document.getElementById('correct-answers').textContent = correctCount;
            document.getElementById('wrong-answers').textContent = wrongCount;
            const progressPercentage = questions.length > 0 ? (answeredQuestions.size / questions.length) * 100 : 0; // Avoid division by zero
            document.getElementById('progress-percentage').textContent = progressPercentage.toFixed(1);
            document.getElementById('progress-bar').style.width = progressPercentage + '%';

            document.getElementById('avg-accuracy').textContent = calculateAccuracy().toFixed(1);
            document.getElementById('max-streak').textContent = maxStreak;
            document.getElementById('current-streak').textContent = renzokuseikai;
            document.getElementById('avg-time').textContent = calculateAverageTime();

            updateChart();
            updateStudyList();
        }

        function onAnswerClick(e) {
            document.querySelector('.swiper-button-next').style.display = 'none';
            document.querySelector('.swiper-button-prev').style.display = 'none';

            // --- タイマー制御: startが未定義の場合のフォールバック ---
            if (typeof start === 'undefined' || start === null) {
                console.warn("Timer start time not set. Using current time.");
                start = performance.now(); // 念のため現在時刻を開始時刻とする
            }
            // --- タイマー制御ここまで ---

            const endTime = performance.now();
            const timeTaken = endTime - start;
            answerTimes.push(timeTaken);
            start = null; // 次の問題が表示されるまでタイマー開始時刻をリセット

            const avgTime = calculateAverageTime();
            // 時間がかかったかの判定: 平均の1.5倍以上、かつ最低でも5秒以上かかった場合など調整可能
            const isLongTime = timeTaken / 1000 > Math.max(5, avgTime * 1.5);


            if (!questionStats.has(currentIndex)) {
                questionStats.set(currentIndex, {
                    attempts: 0,
                    correctAnswers: 0,
                    averageTime: 0,
                    isLongTime: false,
                    isWrong: false
                });
            }

            const stats = questionStats.get(currentIndex);
            stats.attempts++;
            // 平均解答時間の計算を更新 (より正確に)
            stats.averageTime = ((stats.averageTime || 0) * (stats.attempts - 1) + timeTaken) / stats.attempts;
            stats.isLongTime = isLongTime || stats.isLongTime; // 一度でも時間がかかったらフラグを立てる

            answeredQuestions.add(currentIndex);
            totalCount++;

            const isReversed = localStorage.getItem('replace_mondai') === 'true';
            const correctAnswer = isReversed ? questions[currentIndex].description : questions[currentIndex].word;

            if (e.target.textContent === correctAnswer) { // 正解の場合
                stats.isWrong = false; // 正解したので不正解フラグはリセット
                if (isInReviewMode) {
                    // --- 復習モードの正解処理 ---
                    reviewStreaks[currentIndex] = (reviewStreaks[currentIndex] || 0) + 1; // reviewStreaks[currentIndex]が存在しない場合も考慮
                    if (reviewStreaks[currentIndex] >= 2) {
                        const indexToRemove = reviewQuestions.indexOf(currentIndex);
                        if (indexToRemove > -1) {
                            reviewQuestions.splice(indexToRemove, 1);
                        }
                        delete reviewStreaks[currentIndex];
                        studyingQuestions.delete(currentIndex); // 復習完了したら学習中リストからも削除

                        if (reviewQuestions.length === 0) {
                            isInReviewMode = false;
                            document.getElementById('review-mode-indicator').style.display = 'none';
                            document.getElementById('exit-review-btn').style.display = 'none';
                            notie.alert({ type: 'success', text: '復習完了！お疲れ様でした。', time: 3 });
                            document.getElementById('review-count').textContent = reviewQuestions.length;

                            swiper.slideTo(0); // 学習進捗画面へ
                            updateStats();
                            saveProgressToServer(); // 進捗保存
                            return; // 次の問題表示に進まない
                        }
                    }
                    // 通常の正解処理も実行 (スコア加算など)
                    correctCount++;
                    renzokuseikai++;
                    if (renzokuseikai > maxStreak) {
                        maxStreak = renzokuseikai;
                    }
                    stats.correctAnswers = (stats.correctAnswers || 0) + 1; // correctAnswersが存在しない場合も考慮
                    notie.alert({ type: 1, text: '正解', time: 1 });
                    updateProgressDisplay();
                    document.getElementById('review-count').textContent = reviewQuestions.length;

                    updateStats();
                    nextIndex();
                    showNextQuestion();
                    sendScore("add_correct", accid, password);
                    saveProgressToServer(); // 進捗保存
                    // --- 復習モードの正解処理 ここまで ---
                } else {
                    // --- 通常モードの正解処理 ---
                    correctCount++;
                    renzokuseikai++;
                    if (renzokuseikai > maxStreak) {
                        maxStreak = renzokuseikai;
                    }
                    stats.correctAnswers = (stats.correctAnswers || 0) + 1; // correctAnswersが存在しない場合も考慮
                    // 正解回数が2回以上、かつ時間がかかっていない場合に学習中から外す
                    if (stats.correctAnswers >= 2 && !stats.isLongTime) {
                        studyingQuestions.delete(currentIndex);
                    } else if (stats.correctAnswers >= 1 && isLongTime) {
                        studyingQuestions.add(currentIndex); // 1回正解でも時間がかかったら学習中に戻す
                    }
                    notie.alert({ type: 1, text: '正解', time: 1 });
                    updateProgressDisplay();
                    updateStats();
                    nextIndex();
                    showNextQuestion();
                    sendScore("add_correct", accid, password);
                    saveProgressToServer(); // 進捗保存
                    // --- 通常モードの正解処理 ここまで ---
                }
            } else { // 不正解の場合
                stats.isWrong = true; // 不正解フラグを立てる
                studyingQuestions.add(currentIndex); // 不正解なら必ず学習中リストへ
                if (isInReviewMode) {
                    // --- 復習モードの不正解処理 ---
                    reviewStreaks[currentIndex] = 0; // 連続正解リセット
                    // 通常の不正解処理も実行 (スコア加算など)
                    wrongCount++;
                    renzokuseikai = 0;
                    // stats.isWrong = true; // 上で設定済み
                    // studyingQuestions.add(currentIndex); // 上で設定済み
                    let question = questions[currentIndex];
                    let questionText, answerText;
                    if (isReversed) {
                        questionText = question.word;
                        answerText = question.description;
                    } else {
                        questionText = question.description;
                        answerText = question.word;
                    }
                    notie.force({
                        type: 'error',
                        text: '<div class="popup">' + questionText + '<br><br>正しい回答:' + answerText + "<br>あなたの回答:" + e.target.textContent + '</div>',
                        buttonText: '私は間違えたことを深くお詫び、反省することを誓います。',
                        callback: function () {
                            updateProgressDisplay();
                            updateStats();
                            nextIndex(); // 復習モードでも次の問題へ
                            showNextQuestion();
                            sendScore("add_bad", accid, password);
                            saveProgressToServer(); // 進捗保存
                        }
                    });
                } else {
                    wrongCount++;
                    renzokuseikai = 0;
                    // stats.isWrong = true; // 上で設定済み
                    // studyingQuestions.add(currentIndex); // 上で設定済み
                    let question = questions[currentIndex];
                    let questionText, answerText;
                    if (isReversed) {
                        questionText = question.word;
                        answerText = question.description;
                    } else {
                        questionText = question.description;
                        answerText = question.word;
                    }
                    notie.force({
                        type: 'error',
                        text: '<div class="popup">' + questionText + '<br><br>正しい回答:' + answerText + "<br>あなたの回答:" + e.target.textContent + '</div>',
                        buttonText: '私は間違えたことを深くお詫び、反省することを誓います。',
                        callback: function () {
                            updateProgressDisplay();
                            updateStats();
                            // 通常モードの不正解時は同じ問題を表示（nextIndexを呼ばない）
                            // nextIndex(); // この行を削除またはコメントアウト
                            showNextQuestion();
                            sendScore("add_bad", accid, password);
                            saveProgressToServer(); // 進捗保存
                        }
                    });
                }
            }

            // 時間がかかった場合も学習中にする（正解・不正解共通）
            if (isLongTime) {
                studyingQuestions.add(currentIndex);
                // 必要ならstats.isLongTimeフラグを再度確認してセット
                stats.isLongTime = true;
                updateStats(); // 表示更新
            }
        }

        function selectQuestionMode() {
            // モード選択時に localStorage から現在のインデックスを読み込むように修正
            const savedMode = localStorage.getItem('question_mode_' + mondai) || 'sequential'; // デフォルトを sequential に変更
            document.getElementById(savedMode + '-mode').checked = true; // UIに反映

            if (savedMode === 'sequential') {
                // 保存されている進捗があれば復元、なければ0から開始
                currentIndex = parseInt(localStorage.getItem('current_question_index_' + mondai) || '0');
                if (currentIndex >= questions.length || currentIndex < 0) currentIndex = 0; // インデックスが範囲外なら最初から
            } else {
                // ランダムモード
                if (questions.length > 0) {
                    currentIndex = Math.floor(Math.random() * questions.length);
                } else {
                    currentIndex = undefined; // 問題がない場合
                }
            }
            console.log(`Question mode selected: ${savedMode}, initial index: ${currentIndex}`);
        }

        function nextIndex() {
            if (questions.length === 0) return; // 問題がない場合は何もしない

            if (isInReviewMode) {
                if (reviewQuestions.length === 0) {
                    // 復習完了時の処理 (念のため)
                    isInReviewMode = false;
                    document.getElementById('review-mode-indicator').style.display = 'none';
                    document.getElementById('exit-review-btn').style.display = 'none';
                    notie.alert({ type: 'success', text: '復習完了！', time: 2 });
                    swiper.slideTo(0);
                    saveProgressToServer(); // 最後に保存
                    return; // 通常のモード選択に進まない
                }
                let lastReviewIndex = currentIndex;
                // reviewQuestionsが空でないことを確認
                if (reviewQuestions.length > 0) {
                    do {
                        currentIndex = reviewQuestions[Math.floor(Math.random() * reviewQuestions.length)];
                    } while (reviewQuestions.length > 1 && currentIndex === lastReviewIndex); // 問題が2つ以上ある場合のみループ
                } else {
                    // 復習対象がなくなったら復習モードを終了
                    isInReviewMode = false;
                    document.getElementById('review-mode-indicator').style.display = 'none';
                    document.getElementById('exit-review-btn').style.display = 'none';
                    notie.alert({ type: 'success', text: '復習完了！', time: 2 });
                    swiper.slideTo(0);
                    saveProgressToServer(); // 最後に保存
                    return;
                }

                updateProgressDisplay(); // 復習モードでも進捗表示を更新
                return; // 通常のモード選択に進まない
            }

            const isSequential = document.getElementById('sequential-mode').checked; // UIの状態を直接確認
            // const isSequential = (localStorage.getItem('question_mode_' + mondai) ?? 'sequential') === 'sequential'; // localStorageベースの場合

            let lastIndex = currentIndex;

            if (isSequential) {
                // 順番モードでは次の問題へ
                currentIndex = (currentIndex + 1) % questions.length;
                // 進捗を保存
                localStorage.setItem('current_question_index_' + mondai, currentIndex.toString());

                // 最後の問題に達して0に戻ったらランダムモードに切り替えるか、通知を出す
                if (currentIndex === 0 && lastIndex === questions.length - 1) { // 厳密に一周したかチェック
                    // ランダムモードに自動で切り替える場合
                    // localStorage.setItem('question_mode_' + mondai, 'random');
                    // document.getElementById('random-mode').checked = true;
                    // document.getElementById('sequential-mode').checked = false;
                    notie.alert({
                        type: 'success',
                        text: 'すべての問題を終了しました。引き続き順番に表示します。', // または 'ランダムモードに切り替えます'
                        time: 3
                    });
                    // selectQuestionMode(); // モードが変わった場合、再選択ロジックを呼ぶ
                }
            } else {
                // ランダムモード（現状の動作）
                if (questions.length > 1) { // 問題が2つ以上ある場合のみループ
                    do {
                        currentIndex = Math.floor(Math.random() * questions.length);
                    } while (currentIndex === lastIndex);
                } else {
                    // 問題が1つしかない場合はインデックスは変わらない
                    currentIndex = 0;
                }
            }
            console.log(`Next index selected: ${currentIndex}`);
            updateProgressDisplay();
        }

        // 進捗表示を更新する関数
        function updateProgressDisplay() {
            const isSequential = document.getElementById('sequential-mode').checked; // UIの状態を確認

            let scoreText = `
                回答数: ${totalCount}
                正解数: ${correctCount}
                不正解数: ${wrongCount}
                連続正解数: ${renzokuseikai}
                正答率: ${calculateAccuracy().toFixed(1)}%
            `;

            if (isSequential && questions.length > 0) {
                // 順番モードでは問題番号も表示 (currentIndexが有効な場合のみ)
                if (currentIndex !== undefined && currentIndex >= 0 && currentIndex < questions.length) {
                    scoreText = `問題 ${currentIndex + 1}/${questions.length}<br>` + scoreText;
                }
            }
            // 復習モードの表示
            if (isInReviewMode) {
                scoreText = `復習中 残り ${reviewQuestions.length} 問<br>` + scoreText;
            }


            document.getElementById('score').innerHTML = scoreText;
        }


        function sendScore(endpoint, id, password) {
            if (!id || !password) return; // ID/Passがない場合は送信しない
            const currentURL = location;
            const url = currentURL.protocol + "//" + currentURL.host + "/api/" + endpoint;
            fetch(url, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    "id": id,
                    "password": password,
                })
            }).then(response => {
                if (!response.ok) {
                    // 401 Unauthorized のようなエラーも考慮
                    console.error('Send score failed:', response.status, response.statusText);
                    // throw new Error('Network response was not ok ' + response.statusText);
                    return null; // エラー時は null を返すなど
                }
                return response.json();
            }).then(data => {
                if (data) {
                    console.log('Score update success:', data);
                }
                // saveProgressToServer(); // スコア送信成功時にも保存 (頻繁すぎる可能性あり)
            }).catch((error) => {
                console.error('Error sending score:', error);
            });
        }

        // サーバーに学習進捗データを保存する関数
        async function saveProgressToServer() { // Make async
            const userId = Cookies.get('id');
            const password = Cookies.get('password');
            if (!userId || !password) return; // ID/Passがない場合は保存しない

            const problemSet = mondai || 'default';
            const totalQuestions = questions.length;

            // 1. 詳細データ (details) を作成
            const detailsData = {
                answeredQuestions: Array.from(answeredQuestions), // Convert Set to Array
                questionStats: Object.fromEntries(questionStats), // Convert Map to Object
                maxStreak: maxStreak,
                performanceHistory: performanceHistory,
                answerTimes: answerTimes,
                studyingQuestions: Array.from(studyingQuestions), // Convert Set to Array
                // 順番モードの情報を保存
                currentQuestionIndex: parseInt(localStorage.getItem('current_question_index_' + problemSet) || '0'), // ローカルストレージから取得
                questionMode: localStorage.getItem('question_mode_' + problemSet) || 'sequential', // ローカルストレージから取得
            };

            // learned, learning, unlearned の計算ロジックはそのまま
            let learnedCount = 0;
            let learningCount = 0;

            questionStats.forEach((stats, index) => {
                if (answeredQuestions.has(index)) {
                    // 学習済み条件：正解2回以上 AND 時間がかかっていない
                    if (stats.correctAnswers >= 2 && !stats.isLongTime) {
                        learnedCount++;
                    } else { // それ以外（1回正解、不正解、時間がかかった）は学習中
                        learningCount++;
                    }
                }
            });

            // studyingQuestions に含まれているが stats にない（＝まだ解答していない）ものは learningCount に含めるべきか？
            // answeredQuestions に基づいて計算する方が一貫性がある
            studyingQuestions.forEach(index => {
                if (!answeredQuestions.has(index)) {
                    // まだ解答していないが復習リストに入っている場合？ 基本的には解答済みのはず
                    // learningCount++; // 必要ならカウント
                } else if (!questionStats.has(index) || (questionStats.get(index).correctAnswers < 2 || questionStats.get(index).isLongTime)) {
                    // 解答済みだが学習済み条件を満たさない場合、learningCountに含まれているはず
                }
            });


            const unlearnedCount = totalQuestions - learnedCount - learningCount;

            const summaryData = {
                learned: learnedCount,
                learning: learningCount,
                unlearned: Math.max(0, unlearnedCount), // 負にならないように
                total: totalQuestions
            };


            console.log("Saving Progress - Summary:", summaryData, "Details:", detailsData);

            try {
                const response = await fetch('/api/save_progress', { // Use relative path
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        id: userId,
                        password: password,
                        problem_set: problemSet,
                        summary: summaryData,   // Send summary data
                        details: detailsData    // Send details data
                    }),
                });

                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`HTTP error! status: ${response.status}, message: ${errorText}`);
                }

                const result = await response.json();
                console.log('Progress saved:', result.message);
            } catch (error) {
                console.error('Error saving progress:', error);
                // ユーザーにエラーを通知する（例: notie）
                // notie.alert({ type: 'error', text: '進捗の保存に失敗しました。', time: 2 });
            }
        }


        // サーバーから学習進捗データを取得する関数
        async function loadProgressFromServer() { // Make async
            if (!accid || !password) return;

            const detailsUrl = "/api/get_progress"; // Endpoint for detailed progress
            const summaryUrl = "/api/get"; // Endpoint for summary data (used for dashboard slide)

            try {
                const detailsResponse = await fetch(detailsUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        id: accid,
                        password: password,
                        problem_set: mondai
                    })
                });

                if (!detailsResponse.ok) {
                    if (detailsResponse.status === 404) {
                        console.log(`No progress details found on server for ${mondai}. Starting fresh.`);
                        answeredQuestions = new Set();
                        questionStats = new Map();
                        studyingQuestions = new Set(); // 初期化
                        localStorage.removeItem('current_question_index_' + mondai); // ローカルのインデックスもクリア
                        localStorage.removeItem('question_mode_' + mondai); // ローカルのモードもクリア
                    } else {
                        throw new Error(`Error fetching progress details: ${detailsResponse.statusText}`);
                    }
                } else {
                    const detailsDataResult = await detailsResponse.json();
                    const detailsData = detailsDataResult.progress_details;
                    if (detailsData && Object.keys(detailsData).length > 0) {
                        console.log(`Applying progress details for ${mondai}:`, detailsData);
                        applyProgressData(detailsData); // Apply the loaded details
                    } else {
                        console.log(`No progress details content found on server for ${mondai}. Starting fresh.`);
                        answeredQuestions = new Set();
                        questionStats = new Map();
                        studyingQuestions = new Set(); // 初期化
                        localStorage.removeItem('current_question_index_' + mondai);
                        localStorage.removeItem('question_mode_' + mondai);
                    }
                }

                // 2. Fetch Summary Data (for dashboard slide total count)
                const summaryResponse = await fetch(summaryUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ id: accid, password: password })
                });

                if (!summaryResponse.ok) {
                    console.warn(`Could not fetch summary data: ${summaryResponse.statusText}`);
                } else {
                    const summaryDataResult = await summaryResponse.json();
                    const summary = summaryDataResult.progress_summary || {};
                    const p = summary[mondai] || { learned: 0, learning: 0, unlearned: 0, total: questions.length };
                    // サーバーからの total があればそれを使う、なければ計算値
                    document.getElementById('total-questions').textContent = p.total || questions.length;
                }

                // 3. Update UI after potentially loading data
                updateStats(); // Recalculates stats based on loaded data
                selectQuestionMode(); // ローカルストレージ/サーバーからのモードとインデックスを反映してcurrentIndexを設定
                updateProgressDisplay(); // Updates score display

            } catch (error) {
                console.error('Error loading progress data:', error);
                // Consider showing a user-friendly error message
                notie.alert({ type: 'error', text: '進捗の読み込みに失敗しました。', time: 2 });
            }
        }


        // サーバーから取得した学習進捗データを適用する関数
        function applyProgressData(progressData) {

            answeredQuestions = new Set(progressData.answeredQuestions || []);
            maxStreak = progressData.maxStreak || 0;
            performanceHistory = progressData.performanceHistory || [];
            answerTimes = progressData.answerTimes || [];
            studyingQuestions = new Set(progressData.studyingQuestions || []); // studyingQuestionsも復元

            if (progressData.questionStats && typeof progressData.questionStats === 'object') {
                // questionStats の各エントリを数値キーの Map に変換
                questionStats = new Map();
                for (const key in progressData.questionStats) {
                    if (Object.hasOwnProperty.call(progressData.questionStats, key)) {
                        // キーを数値に変換、statsオブジェクトをそのまま値としてセット
                        questionStats.set(parseInt(key), progressData.questionStats[key]);
                    }
                }
            } else {
                questionStats = new Map();
            }


            // 出題順序と現在の問題インデックスを復元し、ローカルストレージにも保存
            const savedMode = progressData.questionMode || 'sequential'; // デフォルトはsequential
            localStorage.setItem('question_mode_' + mondai, savedMode);
            // UIにも反映
            document.getElementById(savedMode + '-mode').checked = true;


            const savedIndex = progressData.currentQuestionIndex !== undefined ? progressData.currentQuestionIndex : 0;
            // サーバーから取得したインデックスが有効範囲内かチェック
            if (savedIndex >= 0 && savedIndex < questions.length) {
                localStorage.setItem('current_question_index_' + mondai, savedIndex.toString());
                // currentIndex = savedIndex; // selectQuestionMode で設定されるのでここでは不要かも
            } else {
                localStorage.setItem('current_question_index_' + mondai, '0'); // 無効なら0にリセット
                // currentIndex = 0;
            }


            // correctCount, wrongCount, totalCount を questionStats から再計算
            correctCount = 0;
            wrongCount = 0;
            totalCount = 0;
            if (questionStats.size > 0) {
                answeredQuestions.forEach(index => {
                    const stats = questionStats.get(index);
                    if (stats) { // statsが存在する場合のみ計算
                        totalCount += stats.attempts || 0;
                        correctCount += stats.correctAnswers || 0;
                        wrongCount += (stats.attempts || 0) - (stats.correctAnswers || 0);
                    }
                });
            } else {
                // questionStatsがない場合（古いデータなど）はansweredQuestionsのサイズをtotalCountとする
                totalCount = answeredQuestions.size;
                // この場合、correct/wrongは0のまま（情報がないため）
            }

            // updateStats(); // この関数を呼び出す loadProgressFromServer の最後で updateStats が呼ばれるので、ここでは不要
        }


        document.getElementById('answer1').addEventListener('click', onAnswerClick);
        document.getElementById('answer2').addEventListener('click', onAnswerClick);
        document.getElementById('answer3').addEventListener('click', onAnswerClick);
        document.getElementById('answer4').addEventListener('click', onAnswerClick);

        // モーダルを初期化
        MicroModal.init({
            awaitOpenAnimation: true,
            awaitCloseAnimation: true
        });
        document.getElementById('settings-btn').addEventListener('click', function () {
            MicroModal.show('settings-modal');
        });

        // --- レーベンシュタイン距離計算関数 ---
        function calculateLevenshteinDistance(a, b) {
            if (a.length === 0) return b.length;
            if (b.length === 0) return a.length;

            const matrix = [];

            // increment along the first column of each row
            for (let i = 0; i <= b.length; i++) {
                matrix[i] = [i];
            }

            // increment each column in the first row
            for (let j = 0; j <= a.length; j++) {
                matrix[0][j] = j;
            }

            // Fill in the rest of the matrix
            for (let i = 1; i <= b.length; i++) {
                for (let j = 1; j <= a.length; j++) {
                    const cost = (b.charAt(i - 1) === a.charAt(j - 1)) ? 0 : 1;
                    matrix[i][j] = Math.min(
                        matrix[i - 1][j] + 1, // deletion
                        matrix[i][j - 1] + 1, // insertion
                        matrix[i - 1][j - 1] + cost // substitution
                    );
                }
            }

            return matrix[b.length][a.length];
        }
        // --- レーベンシュタイン距離計算関数 ここまで ---


        // 問題文と回答文を入れ換える機能
        const replaceMondaiCheckbox = document.getElementById('replace-mondai');

        // ローカルストレージから設定を読み込む
        replaceMondaiCheckbox.checked = localStorage.getItem('replace_mondai') === 'true';

        // チェックボックスの変更イベント
        replaceMondaiCheckbox.addEventListener('change', function () {
            localStorage.setItem('replace_mondai', this.checked);

            // 現在の画面に合わせて更新
            populateWordList(); // 単語リスト再表示

            if (swiper.activeIndex === 1) {
                // 問題画面表示中なら問題も更新
                showNextQuestion();
                notie.alert({
                    type: 'info', // 'success'から変更
                    text: this.checked ? '問題文と回答文を入れ替えました' : '問題文と回答文を元に戻しました',
                    time: 1.5
                });
            }

            swiper.update(); // スワイパー更新
        });

        // ハードモード機能
        const hardmodeCheckbox = document.getElementById('hardmode');

        // ローカルストレージからハードモード設定を読み込む
        hardmodeCheckbox.checked = localStorage.getItem('hard_mode') === 'true';

        // ハードモードチェックボックスの変更イベント
        hardmodeCheckbox.addEventListener('change', function () {
            localStorage.setItem('hard_mode', this.checked);

            if (swiper.activeIndex === 1) {
                // 問題画面表示中なら問題も更新
                showNextQuestion();
                notie.alert({
                    type: 'info',
                    text: this.checked ? 'ハードモードを有効にしました' : 'ハードモードを無効にしました',
                    time: 1.5
                });
            }
            // 設定変更をサーバーに保存 (任意)
            // saveProgressToServer();
        });


        // 出題モード選択のイベントリスナー
        document.getElementById('random-mode').addEventListener('change', function () {
            if (this.checked) {
                localStorage.setItem('question_mode_' + mondai, 'random');
                localStorage.removeItem('current_question_index_' + mondai); // ランダムに切り替えたらインデックスは不要
                selectQuestionMode(); // モード選択ロジックを呼び出してcurrentIndexを更新
                showNextQuestion();
                updateProgressDisplay();
                notie.alert({
                    type: 'info',
                    text: 'ランダム出題モードに切り替えました',
                    time: 1.5
                });
                saveProgressToServer(); // 設定変更を保存
            }
        });

        document.getElementById('sequential-mode').addEventListener('change', function () {
            if (this.checked) {
                localStorage.setItem('question_mode_' + mondai, 'sequential');
                // 順番モードに切り替えたら、保存されているインデックス（なければ0）から再開
                selectQuestionMode(); // モード選択ロジックを呼び出してcurrentIndexを更新
                showNextQuestion();
                updateProgressDisplay();
                notie.alert({
                    type: 'info',
                    text: '順番出題モードに切り替えました',
                    time: 1.5
                });
                saveProgressToServer(); // 設定変更を保存
            }
        });


        document.querySelectorAll('input[name="answer-mode"]').forEach(radio => {
            radio.addEventListener('change', function () {
                const choiceArea = document.getElementById('choice-answers');
                const inputArea = document.getElementById('input-area');
                const handwritingArea = document.getElementById('handwriting-area');

                localStorage.setItem('answer_mode', this.value); // 回答モードも保存

                choiceArea.style.display = 'none';
                inputArea.style.display = 'none';
                handwritingArea.style.display = 'none';


                if (this.value === 'choice') {
                    choiceArea.style.display = 'block';
                } else if (this.value === 'input') {
                    inputArea.style.display = 'block';
                    document.getElementById('text-answer').focus();
                } else if (this.value === 'handwriting') {
                    handwritingArea.style.display = 'block';
                    // 手書きモード初期化処理（必要なら）
                }
            });
        });

        // テキスト回答送信
        document.getElementById('submit-text-answer').addEventListener('click', function () {
            const answer = document.getElementById('text-answer').value.trim();
            if (answer) {
                checkTextAnswer(answer);
            }
        });

        // テキスト回答のEnterキー処理
        document.getElementById('text-answer').addEventListener('keypress', function (e) {
            if (e.key === 'Enter') {
                const answer = this.value.trim();
                if (answer) {
                    checkTextAnswer(answer);
                }
            }
        });

        // 正解時の処理 (入力/手書きモード用)
        async function handleCorrectAnswerInput() {
            if (typeof start === 'undefined' || start === null) {
                start = performance.now();
            }
            const endTime = performance.now();
            const timeTaken = endTime - start;
            answerTimes.push(timeTaken);
            start = null;

            if (!questionStats.has(currentIndex)) {
                questionStats.set(currentIndex, { attempts: 0, correctAnswers: 0, averageTime: 0, isLongTime: false, isWrong: false });
            }

            const stats = questionStats.get(currentIndex);
            stats.attempts++;
            stats.averageTime = ((stats.averageTime || 0) * (stats.attempts - 1) + timeTaken) / stats.attempts;
            stats.isWrong = false

            answeredQuestions.add(currentIndex);
            totalCount++;
            correctCount++;
            renzokuseikai++;

            if (renzokuseikai > maxStreak) {
                maxStreak = renzokuseikai;
            }

            stats.correctAnswers = (stats.correctAnswers || 0) + 1;
            const avgTime = calculateAverageTime();
            const isLongTime = timeTaken / 1000 > Math.max(5, avgTime * 1.5);
            stats.isLongTime = isLongTime || stats.isLongTime;

            // 正解回数2回以上、かつ時間がかかっていない場合に学習中から外す
            if (stats.correctAnswers >= 2 && !stats.isLongTime) {
                studyingQuestions.delete(currentIndex);
            } else if (stats.correctAnswers >= 1 && isLongTime) {
                studyingQuestions.add(currentIndex); // 時間がかかったら学習中に戻す
            }


            notie.alert({ type: 1, text: '正解', time: 1 });
            updateProgressDisplay();
            updateStats();

            // 入力フィールド/キャンバスをクリア
            document.getElementById('text-answer').value = '';
            if (window.clearCanvas) clearCanvas(); // write.js の関数があれば呼ぶ

            sendScore("add_correct", accid, password);
            await saveProgressToServer(); // 進捗保存

            nextIndex();
            showNextQuestion();
        }


        // 不正解時の処理 (入力/手書きモード用)
        function handleWrongAnswerInput(userAnswer, correctAnswer) {
            if (typeof start === 'undefined' || start === null) {
                start = performance.now();
            }
            const endTime = performance.now();
            const timeTaken = endTime - start;
            answerTimes.push(timeTaken);
            start = null; // タイマーリセット

            if (!questionStats.has(currentIndex)) {
                questionStats.set(currentIndex, { attempts: 0, correctAnswers: 0, averageTime: 0, isLongTime: false, isWrong: false });
            }

            const stats = questionStats.get(currentIndex);
            stats.attempts++;
            stats.averageTime = ((stats.averageTime || 0) * (stats.attempts - 1) + timeTaken) / stats.attempts;
            stats.isWrong = true; // 不正解フラグ

            answeredQuestions.add(currentIndex);
            totalCount++;
            wrongCount++;
            renzokuseikai = 0;
            studyingQuestions.add(currentIndex); // 不正解なら必ず学習中リストへ

            const avgTime = calculateAverageTime();
            const isLongTime = timeTaken / 1000 > Math.max(5, avgTime * 1.5);
            stats.isLongTime = isLongTime || stats.isLongTime; // 時間がかかったかも記録

            notie.force({
                type: 'error',
                text: '<div class="popup">正しい回答: ' + correctAnswer + '<br>あなたの回答: ' + userAnswer + '</div>',
                buttonText: '私は間違えたことを深くお詫び、反省することを誓います。',
                callback: async function () { // Make callback async
                    // 入力フィールド/キャンバスはクリアしない（間違いを確認できるように）
                    // document.getElementById('text-answer').value = '';
                    // if (window.clearCanvas) clearCanvas();

                    updateProgressDisplay();
                    updateStats();

                    sendScore("add_bad", accid, password);
                    await saveProgressToServer(); // 進捗保存

                    // 不正解時は同じ問題を表示 (nextIndexを呼ばない)
                    showNextQuestion();
                }
            });
        }


        // テキスト回答の正誤チェック
        function checkTextAnswer(answer) {
            const isReversed = localStorage.getItem('replace_mondai') === 'true';
            const correctAnswer = isReversed ? questions[currentIndex].description : questions[currentIndex].word;

            // 完全一致で比較
            if (answer === correctAnswer) {
                handleCorrectAnswerInput();
            } else {
                // ひらがな・カタカナ、全角・半角の違いなどを許容する場合はここで処理を追加
                // 例: normalizeAnswer(answer) === normalizeAnswer(correctAnswer)
                handleWrongAnswerInput(answer, correctAnswer);
            }
        }


        // 手書き回答の送信処理 (write.js側で checkHandwritingAnswer を呼ぶ想定)
        function checkHandwritingAnswer(handwritingResult) {
            const isReversed = localStorage.getItem('replace_mondai') === 'true';
            const correctAnswer = isReversed ? questions[currentIndex].description : questions[currentIndex].word;

            // 手書き認識結果 (handwritingResult) と正解 (correctAnswer) を比較
            // 認識結果が複数候補ある場合は、いずれかが一致すれば正解とするなどの処理が必要
            // ここでは単純に最初の候補と比較する例
            if (handwritingResult && handwritingResult.length > 0 && handwritingResult[0] === correctAnswer) {
                handleCorrectAnswerInput();
            } else {
                handleWrongAnswerInput(handwritingResult ? handwritingResult.join(', ') : '認識失敗', correctAnswer);
            }
        }


        document.addEventListener('DOMContentLoaded', function () {
            // 保存された出題順序モードを読み込む
            selectQuestionMode(); // これでlocalStorageが読み込まれUIに反映される

            // 保存された回答モードを読み込む
            const savedAnswerMode = localStorage.getItem('answer_mode') || 'choice';
            document.getElementById(savedAnswerMode + '-mode').checked = true;
            // イベントを発火させて表示を切り替える
            document.getElementById(savedAnswerMode + '-mode').dispatchEvent(new Event('change'));

            const savedReplaceMode = localStorage.getItem('replace_mondai') === 'true';
            document.getElementById('replace-mondai').checked = savedReplaceMode;

            // 保存されたハードモード設定を読み込む
            const savedHardMode = localStorage.getItem('hard_mode') === 'true';
            document.getElementById('hardmode').checked = savedHardMode;

            //タイトルの変更
            document.title = `Quizbox - ${getParam("id")}`;
        });

        // 復習モード開始ボタンのイベントリスナー
        document.getElementById('start-review-btn').addEventListener('click', function () {
            reviewQuestions = Array.from(studyingQuestions);
            if (reviewQuestions.length === 0) {
                notie.alert({ type: 'info', text: '復習する問題はありません。', time: 2 });
                return;
            }

            isInReviewMode = true;
            reviewStreaks = {};
            reviewQuestions.forEach(index => reviewStreaks[index] = 0); // Streaks初期化

            // 復習モードの最初の問題を設定 (ランダムに)
            if (reviewQuestions.length > 0) {
                currentIndex = reviewQuestions[Math.floor(Math.random() * reviewQuestions.length)];
            } else {
                // 念のため復習対象がない場合の処理
                isInReviewMode = false;
                notie.alert({ type: 'info', text: 'エラー: 復習対象がありません。', time: 2 });
                return;
            }


            document.getElementById('review-mode-indicator').style.display = 'block';
            document.getElementById('exit-review-btn').style.display = 'block';
            document.getElementById('review-count').textContent = reviewQuestions.length;

            swiper.slideTo(1); // クイズ画面へ移動
            showNextQuestion();
            updateProgressDisplay(); // 進捗表示も更新
            notie.alert({ type: 'info', text: '復習モードを開始します。', time: 1.5 });
            // 復習モード開始時もタイマー開始
            start = performance.now();
        });

        // 通常モードに戻るボタンのイベントリスナー
        document.getElementById('exit-review-btn').addEventListener('click', function () {
            isInReviewMode = false;
            document.getElementById('review-mode-indicator').style.display = 'none';
            document.getElementById('exit-review-btn').style.display = 'none';
            notie.alert({ type: 'info', text: '通常モードに戻りました。', time: 1.5 });
            saveProgressToServer(); // 復習モード終了時に進捗保存
            selectQuestionMode(); // 通常のモード選択ロジックを再実行
            showNextQuestion();
            updateProgressDisplay();
            // 通常モードに戻った時もタイマー開始
            start = performance.now();
        });

    </script>
</body>

</html>